<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEAL: seal::Evaluator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SEAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>seal</b></li><li class="navelem"><a class="el" href="classseal_1_1Evaluator.html">Evaluator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classseal_1_1Evaluator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">seal::Evaluator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="evaluator_8h_source.html">evaluator.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab15039b82f9ca97a5bc50a5d528c5938"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#ab15039b82f9ca97a5bc50a5d528c5938">Evaluator</a> (std::shared_ptr&lt; <a class="el" href="classseal_1_1SEALContext.html">SEALContext</a> &gt; context)</td></tr>
<tr class="separator:ab15039b82f9ca97a5bc50a5d528c5938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58ba00f7da21a487a53be509053a8ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#ae58ba00f7da21a487a53be509053a8ee">negate_inplace</a> (<a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted)</td></tr>
<tr class="separator:ae58ba00f7da21a487a53be509053a8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafff833b8482769435ea25cd814af55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#adafff833b8482769435ea25cd814af55">negate</a> (const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;destination)</td></tr>
<tr class="separator:adafff833b8482769435ea25cd814af55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9e0137f157d2600d785ffc0e13c207"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#a2f9e0137f157d2600d785ffc0e13c207">add_inplace</a> (<a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted1, const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted2)</td></tr>
<tr class="separator:a2f9e0137f157d2600d785ffc0e13c207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac154f02445725698533babdc39f3ba16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#ac154f02445725698533babdc39f3ba16">add</a> (const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted1, const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted2, <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;destination)</td></tr>
<tr class="separator:ac154f02445725698533babdc39f3ba16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c6eaad6c698929004b6870fffe7394"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#a45c6eaad6c698929004b6870fffe7394">add_many</a> (const std::vector&lt; <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &gt; &amp;encrypteds, <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;destination)</td></tr>
<tr class="separator:a45c6eaad6c698929004b6870fffe7394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49952ff145ce3f1b2e13f9cdee3ca6ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#a49952ff145ce3f1b2e13f9cdee3ca6ec">sub_inplace</a> (<a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted1, const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted2)</td></tr>
<tr class="separator:a49952ff145ce3f1b2e13f9cdee3ca6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e89e02a7a60ee15bc544966e48cf82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#ac5e89e02a7a60ee15bc544966e48cf82">sub</a> (const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted1, const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted2, <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;destination)</td></tr>
<tr class="separator:ac5e89e02a7a60ee15bc544966e48cf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a270c40a06e75d44443a4ca74dccc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#a80a270c40a06e75d44443a4ca74dccc4">multiply_inplace</a> (<a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted1, const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted2, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:a80a270c40a06e75d44443a4ca74dccc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9131f149deb68c99640d790529a1db4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#af9131f149deb68c99640d790529a1db4">multiply</a> (const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted1, const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted2, <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;destination, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:af9131f149deb68c99640d790529a1db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f13bfd3e06b4f85b6e8f494e76becee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#a5f13bfd3e06b4f85b6e8f494e76becee">square_inplace</a> (<a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:a5f13bfd3e06b4f85b6e8f494e76becee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6ce5aa2b92e9b97db346f91dd39e92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#aba6ce5aa2b92e9b97db346f91dd39e92">square</a> (const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;destination, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:aba6ce5aa2b92e9b97db346f91dd39e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526a3da5daab4a2bed366bde3af23fa3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#a526a3da5daab4a2bed366bde3af23fa3">relinearize_inplace</a> (<a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, const <a class="el" href="classseal_1_1RelinKeys.html">RelinKeys</a> &amp;relin_keys, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:a526a3da5daab4a2bed366bde3af23fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2991b74a5535eb5951e359e209eeeb6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#a2991b74a5535eb5951e359e209eeeb6f">relinearize</a> (const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, const <a class="el" href="classseal_1_1RelinKeys.html">RelinKeys</a> &amp;relin_keys, <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;destination, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:a2991b74a5535eb5951e359e209eeeb6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f13048686ae44b508bcbd467bac627"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#a23f13048686ae44b508bcbd467bac627">mod_switch_to_next</a> (const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;destination, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:a23f13048686ae44b508bcbd467bac627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f9a3adef2f00526fc7ffa02c32a5c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#a09f9a3adef2f00526fc7ffa02c32a5c9">mod_switch_to_next_inplace</a> (<a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:a09f9a3adef2f00526fc7ffa02c32a5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89e2b0e74e7b5cd3d4a1d7923ec19e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#af89e2b0e74e7b5cd3d4a1d7923ec19e8">mod_switch_to_next_inplace</a> (<a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;plain)</td></tr>
<tr class="separator:af89e2b0e74e7b5cd3d4a1d7923ec19e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821eaf26522d2544ef76826ad1dcc4df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#a821eaf26522d2544ef76826ad1dcc4df">mod_switch_to_next</a> (const <a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;plain, <a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;destination)</td></tr>
<tr class="separator:a821eaf26522d2544ef76826ad1dcc4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb372ae05b05d3524093e607ee4f382d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#abb372ae05b05d3524093e607ee4f382d">mod_switch_to_inplace</a> (<a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, parms_id_type parms_id, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:abb372ae05b05d3524093e607ee4f382d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e603dbfcd7e26ecf6eaa746d6fbac50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#a3e603dbfcd7e26ecf6eaa746d6fbac50">mod_switch_to</a> (const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, parms_id_type parms_id, <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;destination, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:a3e603dbfcd7e26ecf6eaa746d6fbac50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1193dae509bf5b1effab1afdc1b1d0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#ab1193dae509bf5b1effab1afdc1b1d0e">mod_switch_to_inplace</a> (<a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;plain, parms_id_type parms_id)</td></tr>
<tr class="separator:ab1193dae509bf5b1effab1afdc1b1d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87e03471a8a1e7c2214f9cfc91c0258"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#ad87e03471a8a1e7c2214f9cfc91c0258">mod_switch_to</a> (const <a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;plain, parms_id_type parms_id, <a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;destination)</td></tr>
<tr class="separator:ad87e03471a8a1e7c2214f9cfc91c0258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee79b403a31f0b24d587063303129e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#acee79b403a31f0b24d587063303129e7">rescale_to_next</a> (const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;destination, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:acee79b403a31f0b24d587063303129e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa075f8db976da32643c1d6c663215a32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#aa075f8db976da32643c1d6c663215a32">rescale_to_next_inplace</a> (<a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:aa075f8db976da32643c1d6c663215a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae347aebd276af11671803e67efdcad05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#ae347aebd276af11671803e67efdcad05">rescale_to_inplace</a> (<a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, parms_id_type parms_id, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:ae347aebd276af11671803e67efdcad05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47bafd672948e8c9b8550327bdcbb930"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#a47bafd672948e8c9b8550327bdcbb930">rescale_to</a> (const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, parms_id_type parms_id, <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;destination, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:a47bafd672948e8c9b8550327bdcbb930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fad97d58e0547e7839a7e92c5b2a25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#ad6fad97d58e0547e7839a7e92c5b2a25">multiply_many</a> (std::vector&lt; <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &gt; &amp;encrypteds, const <a class="el" href="classseal_1_1RelinKeys.html">RelinKeys</a> &amp;relin_keys, <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;destination, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:ad6fad97d58e0547e7839a7e92c5b2a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c72d17b1a0a1e0d5f843f26b33c662f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#a6c72d17b1a0a1e0d5f843f26b33c662f">exponentiate_inplace</a> (<a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, std::uint64_t exponent, const <a class="el" href="classseal_1_1RelinKeys.html">RelinKeys</a> &amp;relin_keys, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:a6c72d17b1a0a1e0d5f843f26b33c662f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36614f5a6b25f1ef05af56562e0c9bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#af36614f5a6b25f1ef05af56562e0c9bf">exponentiate</a> (const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, std::uint64_t exponent, const <a class="el" href="classseal_1_1RelinKeys.html">RelinKeys</a> &amp;relin_keys, <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;destination, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:af36614f5a6b25f1ef05af56562e0c9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba307a1b05599499261936b7ec342cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#abba307a1b05599499261936b7ec342cb">add_plain_inplace</a> (<a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, const <a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;plain)</td></tr>
<tr class="separator:abba307a1b05599499261936b7ec342cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a6b25b1b78bebd5c0e21143a803193"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#a09a6b25b1b78bebd5c0e21143a803193">add_plain</a> (const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, const <a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;plain, <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;destination)</td></tr>
<tr class="separator:a09a6b25b1b78bebd5c0e21143a803193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28cdbf1304d001bdcc5e6ca33c7462f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#ac28cdbf1304d001bdcc5e6ca33c7462f">sub_plain_inplace</a> (<a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, const <a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;plain)</td></tr>
<tr class="separator:ac28cdbf1304d001bdcc5e6ca33c7462f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3fe78f97051e39a44d35d20fe1e618"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#a3e3fe78f97051e39a44d35d20fe1e618">sub_plain</a> (const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, const <a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;plain, <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;destination)</td></tr>
<tr class="separator:a3e3fe78f97051e39a44d35d20fe1e618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0dba483435b810b33ede2ffadd3ca8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#a6a0dba483435b810b33ede2ffadd3ca8">multiply_plain_inplace</a> (<a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, const <a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;plain, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:a6a0dba483435b810b33ede2ffadd3ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abfa74a172611ff3074bc035e4c4cb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#a7abfa74a172611ff3074bc035e4c4cb9">multiply_plain</a> (const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, const <a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;plain, <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;destination, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:a7abfa74a172611ff3074bc035e4c4cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8845e9d44668045c3d5721babe69c172"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#a8845e9d44668045c3d5721babe69c172">transform_to_ntt_inplace</a> (<a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;plain, parms_id_type parms_id, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:a8845e9d44668045c3d5721babe69c172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d69437cb36e358bd9ca53c76a9d7be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#af2d69437cb36e358bd9ca53c76a9d7be">transform_to_ntt</a> (const <a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;plain, parms_id_type parms_id, <a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;destination_ntt, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:af2d69437cb36e358bd9ca53c76a9d7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8daf73494c4849bfa6740256e8c856"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#a7f8daf73494c4849bfa6740256e8c856">transform_to_ntt_inplace</a> (<a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted)</td></tr>
<tr class="separator:a7f8daf73494c4849bfa6740256e8c856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969fc02ff4f26b7ec09faeed550302ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#a969fc02ff4f26b7ec09faeed550302ed">transform_to_ntt</a> (const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;destination_ntt)</td></tr>
<tr class="separator:a969fc02ff4f26b7ec09faeed550302ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb91aa496134803abd084a1307041b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#a8bb91aa496134803abd084a1307041b3">transform_from_ntt_inplace</a> (<a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted_ntt)</td></tr>
<tr class="separator:a8bb91aa496134803abd084a1307041b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4b08d357b06baa53036a087799dc10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#a4b4b08d357b06baa53036a087799dc10">transform_from_ntt</a> (const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted_ntt, <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;destination)</td></tr>
<tr class="separator:a4b4b08d357b06baa53036a087799dc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52efc9b28679d0d8e82fb1e6942195c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#ac52efc9b28679d0d8e82fb1e6942195c">apply_galois_inplace</a> (<a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, std::uint64_t galois_elt, const <a class="el" href="classseal_1_1GaloisKeys.html">GaloisKeys</a> &amp;galois_keys, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:ac52efc9b28679d0d8e82fb1e6942195c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2558687de3f7ab51ad8974b85900256"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#ac2558687de3f7ab51ad8974b85900256">apply_galois</a> (const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, std::uint64_t galois_elt, const <a class="el" href="classseal_1_1GaloisKeys.html">GaloisKeys</a> &amp;galois_keys, <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;destination, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:ac2558687de3f7ab51ad8974b85900256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3447cb7bd61c93b2c37b7216071725"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#a5f3447cb7bd61c93b2c37b7216071725">rotate_rows_inplace</a> (<a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, int steps, const <a class="el" href="classseal_1_1GaloisKeys.html">GaloisKeys</a> &amp;galois_keys, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:a5f3447cb7bd61c93b2c37b7216071725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7c73d2903d4afae7969340c8d3c21c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#afa7c73d2903d4afae7969340c8d3c21c">rotate_rows</a> (const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, int steps, const <a class="el" href="classseal_1_1GaloisKeys.html">GaloisKeys</a> &amp;galois_keys, <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;destination, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:afa7c73d2903d4afae7969340c8d3c21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de4e73e74186dc3b7e6c3a3545b95d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#a3de4e73e74186dc3b7e6c3a3545b95d0">rotate_columns_inplace</a> (<a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, const <a class="el" href="classseal_1_1GaloisKeys.html">GaloisKeys</a> &amp;galois_keys, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:a3de4e73e74186dc3b7e6c3a3545b95d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7340b8eb509b787ef8c706e3e657adf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#af7340b8eb509b787ef8c706e3e657adf">rotate_columns</a> (const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, const <a class="el" href="classseal_1_1GaloisKeys.html">GaloisKeys</a> &amp;galois_keys, <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;destination, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:af7340b8eb509b787ef8c706e3e657adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf21800889afc62f8b733391602e6b57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#abf21800889afc62f8b733391602e6b57">rotate_vector_inplace</a> (<a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, int steps, const <a class="el" href="classseal_1_1GaloisKeys.html">GaloisKeys</a> &amp;galois_keys, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:abf21800889afc62f8b733391602e6b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164b7b937cbb21a139ab0413f7e22612"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#a164b7b937cbb21a139ab0413f7e22612">rotate_vector</a> (const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, int steps, const <a class="el" href="classseal_1_1GaloisKeys.html">GaloisKeys</a> &amp;galois_keys, <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;destination, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:a164b7b937cbb21a139ab0413f7e22612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f60762fa9a418984232434c60ef4186"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#a8f60762fa9a418984232434c60ef4186">complex_conjugate_inplace</a> (<a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, const <a class="el" href="classseal_1_1GaloisKeys.html">GaloisKeys</a> &amp;galois_keys, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:a8f60762fa9a418984232434c60ef4186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9758bce495fb4b71396dde22e9dccbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1Evaluator.html#ad9758bce495fb4b71396dde22e9dccbe">complex_conjugate</a> (const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;encrypted, const <a class="el" href="classseal_1_1GaloisKeys.html">GaloisKeys</a> &amp;galois_keys, <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;destination, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:ad9758bce495fb4b71396dde22e9dccbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides operations on ciphertexts. Due to the properties of the encryption scheme, the arithmetic operations pass through the encryption layer to the underlying plaintext, changing it according to the type of the operation. Since the plaintext elements are fundamentally polynomials in the polynomial quotient ring Z_T[x]/(X^N+1), where T is the plaintext modulus and X^N+1 is the polynomial modulus, this is the ring where the arithmetic operations will take place. <a class="el" href="classseal_1_1BatchEncoder.html">BatchEncoder</a> (batching) provider an alternative possibly more convenient view of the plaintext elements as 2-by-(N2/2) matrices of integers modulo the plaintext modulus. In the batching view the arithmetic operations act on the matrices element-wise. Some of the operations only apply in the batching view, such as matrix row and column rotations. Other operations such as relinearization have no semantic meaning but are necessary for performance reasons.</p>
<dl class="section user"><dt>Arithmetic Operations</dt><dd>The core operations are arithmetic operations, in particular multiplication and addition of ciphertexts. In addition to these, we also provide negation, subtraction, squaring, exponentiation, and multiplication and addition of several ciphertexts for convenience. in many cases some of the inputs to a computation are plaintext elements rather than ciphertexts. For this we provide fast "plain" operations: plain addition, plain subtraction, and plain multiplication.</dd></dl>
<dl class="section user"><dt>Relinearization</dt><dd>One of the most important non-arithmetic operations is relinearization, which takes as input a ciphertext of size K+1 and relinearization keys (at least K-1 keys are needed), and changes the size of the ciphertext down to 2 (minimum size). For most use-cases only one relinearization key suffices, in which case relinearization should be performed after every multiplication. Homomorphic multiplication of ciphertexts of size K+1 and L+1 outputs a ciphertext of size K+L+1, and the computational cost of multiplication is proportional to K*L. Plain multiplication and addition operations of any type do not change the size. The performance of relinearization is determined by the decomposition bit count that the relinearization keys were generated with.</dd></dl>
<dl class="section user"><dt>Rotations</dt><dd>When batching is enabled, we provide operations for rotating the plaintext matrix rows cyclically left or right, and for rotating the columns (swapping the rows). Rotations require Galois keys to have been generated, and their performance depends on the decomposition bit count that the Galois keys were generated with.</dd></dl>
<dl class="section user"><dt>Other Operations</dt><dd>We also provide operations for transforming ciphertexts to NTT form and back, and for transforming plaintext polynomials to NTT form. These can be used in a very fast plain multiplication variant, that assumes the inputs to be in NTT form. Since the NTT has to be done in any case in plain multiplication, this function can be used when e.g. one plaintext input is used in several plain multiplication, and transforming it several times would not make sense.</dd></dl>
<dl class="section user"><dt>NTT form</dt><dd>When using the BFV scheme (scheme_type::BFV), all plaintexts and ciphertexts should remain by default in the usual coefficient representation, i.e. not in NTT form. When using the CKKS scheme (scheme_type::CKKS), all plaintexts and ciphertexts should remain by default in NTT form. We call these scheme- specific NTT states the "default NTT form". Some functions, such as add, work even if the inputs are not in the default state, but others, such as multiply, will throw an exception. The output of all evaluation functions will be in the same state as the input(s), with the exception of the transform_to_ntt and transform_from_ntt functions, which change the state. Ideally, unless these two functions are called, all other functions should "just work".</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classseal_1_1EncryptionParameters.html">EncryptionParameters</a> for more details on encryption parameters. </dd>
<dd>
<a class="el" href="classseal_1_1BatchEncoder.html">BatchEncoder</a> for more details on batching </dd>
<dd>
<a class="el" href="classseal_1_1RelinKeys.html">RelinKeys</a> for more details on relinearization keys. </dd>
<dd>
<a class="el" href="classseal_1_1GaloisKeys.html">GaloisKeys</a> for more details on Galois keys. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab15039b82f9ca97a5bc50a5d528c5938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15039b82f9ca97a5bc50a5d528c5938">&#9670;&nbsp;</a></span>Evaluator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">seal::Evaluator::Evaluator </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classseal_1_1SEALContext.html">SEALContext</a> &gt;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an <a class="el" href="classseal_1_1Evaluator.html">Evaluator</a> instance initialized with the specified <a class="el" href="classseal_1_1SEALContext.html">SEALContext</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The <a class="el" href="classseal_1_1SEALContext.html">SEALContext</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the context is not set or encryption parameters are not valid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac154f02445725698533babdc39f3ba16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac154f02445725698533babdc39f3ba16">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds two ciphertexts. This function adds together encrypted1 and encrypted2 and stores the result in the destination parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted1</td><td>The first ciphertext to add </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted2</td><td>The second ciphertext to add </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the addition result </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted1 or encrypted2 is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted1 and encrypted2 are in different NTT forms </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted1 and encrypted2 have different scale </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f9e0137f157d2600d785ffc0e13c207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9e0137f157d2600d785ffc0e13c207">&#9670;&nbsp;</a></span>add_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::add_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds two ciphertexts. This function adds together encrypted1 and encrypted2 and stores the result in encrypted1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted1</td><td>The first ciphertext to add </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted2</td><td>The second ciphertext to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted1 or encrypted2 is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted1 and encrypted2 are in different NTT forms </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted1 and encrypted2 have different scale </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45c6eaad6c698929004b6870fffe7394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c6eaad6c698929004b6870fffe7394">&#9670;&nbsp;</a></span>add_many()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::add_many </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>encrypteds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds together a vector of ciphertexts and stores the result in the destination parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypteds</td><td>The ciphertexts to add </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the addition result </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypteds is empty </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the encrypteds are not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypteds are in different NTT forms </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypteds have different scale </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if destination is one of encrypteds </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09a6b25b1b78bebd5c0e21143a803193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a6b25b1b78bebd5c0e21143a803193">&#9670;&nbsp;</a></span>add_plain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::add_plain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a ciphertext and a plaintext. This function adds a ciphertext and a plaintext and stores the result in the destination parameter. The plaintext must be valid for the current encryption parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to add </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>The plaintext to add </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the addition result </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted or plain is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted or plain is in NTT form </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abba307a1b05599499261936b7ec342cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba307a1b05599499261936b7ec342cb">&#9670;&nbsp;</a></span>add_plain_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::add_plain_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a ciphertext and a plaintext. The plaintext must be valid for the current encryption parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to add </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>The plaintext to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted or plain is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted or plain is in NTT form </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2558687de3f7ab51ad8974b85900256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2558687de3f7ab51ad8974b85900256">&#9670;&nbsp;</a></span>apply_galois()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::apply_galois </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>galois_elt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1GaloisKeys.html">GaloisKeys</a> &amp;&#160;</td>
          <td class="paramname"><em>galois_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a Galois automorphism to a ciphertext and writes the result to the destination parameter. To evaluate the Galois automorphism, an appropriate set of Galois keys must also be provided. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<p>The desired Galois automorphism is given as a Galois element, and must be an odd integer in the interval [1, M-1], where M = 2*N, and N = degree(poly_modulus). Used with batching, a Galois element 3^i % M corresponds to a cyclic row rotation i steps to the left, and a Galois element 3^(N/2-i) % M corresponds to a cyclic row rotation i steps to the right. The Galois element M-1 corresponds to a column rotation (row swap) in BFV, and complex conjugation in CKKS. In the polynomial view (not batching), a Galois automorphism by a Galois element p changes Enc(plain(x)) to Enc(plain(x^p)).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to apply the Galois automorphism to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">galois_elt</td><td>The Galois element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">galois_keys</td><td>The Galois keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted or galois_keys is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if galois_keys do not correspond to the top level parameters in the current context </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not in the default NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted has size larger than 2 </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the Galois element is not valid </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if necessary Galois keys are not present </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac52efc9b28679d0d8e82fb1e6942195c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac52efc9b28679d0d8e82fb1e6942195c">&#9670;&nbsp;</a></span>apply_galois_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::apply_galois_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>galois_elt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1GaloisKeys.html">GaloisKeys</a> &amp;&#160;</td>
          <td class="paramname"><em>galois_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies a Galois automorphism to a ciphertext. To evaluate the Galois automorphism, an appropriate set of Galois keys must also be provided. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<p>The desired Galois automorphism is given as a Galois element, and must be an odd integer in the interval [1, M-1], where M = 2*N, and N = degree(poly_modulus). Used with batching, a Galois element 3^i % M corresponds to a cyclic row rotation i steps to the left, and a Galois element 3^(N/2-i) % M corresponds to a cyclic row rotation i steps to the right. The Galois element M-1 corresponds to a column rotation (row swap) in BFV, and complex conjugation in CKKS. In the polynomial view (not batching), a Galois automorphism by a Galois element p changes Enc(plain(x)) to Enc(plain(x^p)).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to apply the Galois automorphism to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">galois_elt</td><td>The Galois element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">galois_keys</td><td>The Galois keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted or galois_keys is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if galois_keys do not correspond to the top level parameters in the current context </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not in the default NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted has size larger than 2 </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the Galois element is not valid </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if necessary Galois keys are not present </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9758bce495fb4b71396dde22e9dccbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9758bce495fb4b71396dde22e9dccbe">&#9670;&nbsp;</a></span>complex_conjugate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::complex_conjugate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1GaloisKeys.html">GaloisKeys</a> &amp;&#160;</td>
          <td class="paramname"><em>galois_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Complex conjugates plaintext slot values. When using the CKKS scheme, this function complex conjugates all values in the underlying plaintext, and writes the result to the destination parameter. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to rotate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">galois_keys</td><td>The Galois keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the rotated result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if scheme is not scheme_type::CKKS </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted or galois_keys is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if galois_keys do not correspond to the top level parameters in the current context </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is in NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted has size larger than 2 </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if necessary Galois keys are not present </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f60762fa9a418984232434c60ef4186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f60762fa9a418984232434c60ef4186">&#9670;&nbsp;</a></span>complex_conjugate_inplace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::complex_conjugate_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1GaloisKeys.html">GaloisKeys</a> &amp;&#160;</td>
          <td class="paramname"><em>galois_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Complex conjugates plaintext slot values. When using the CKKS scheme, this function complex conjugates all values in the underlying plaintext. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to rotate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">galois_keys</td><td>The Galois keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the rotated result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if scheme is not scheme_type::CKKS </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted or galois_keys is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if galois_keys do not correspond to the top level parameters in the current context </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is in NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted has size larger than 2 </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if necessary Galois keys are not present </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af36614f5a6b25f1ef05af56562e0c9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36614f5a6b25f1ef05af56562e0c9bf">&#9670;&nbsp;</a></span>exponentiate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::exponentiate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>exponent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1RelinKeys.html">RelinKeys</a> &amp;&#160;</td>
          <td class="paramname"><em>relin_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exponentiates a ciphertext. This functions raises encrypted to a power and stores the result in the destination parameter. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>. The exponentiation is done in a depth-optimal order, and relinearization is performed automatically after every multiplication in the process. In relinearization the given relinearization keys are used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to exponentiate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exponent</td><td>The power to raise the ciphertext to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relin_keys</td><td>The relinearization keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the power </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if scheme is not scheme_type::BFV </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted or relin_keys is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not in the default NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if, when using scheme_type::CKKS, the output scale is too large for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if exponent is zero </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the size of relin_keys is too small </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c72d17b1a0a1e0d5f843f26b33c662f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c72d17b1a0a1e0d5f843f26b33c662f">&#9670;&nbsp;</a></span>exponentiate_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::exponentiate_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>exponent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1RelinKeys.html">RelinKeys</a> &amp;&#160;</td>
          <td class="paramname"><em>relin_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exponentiates a ciphertext. This functions raises encrypted to a power. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>. The exponentiation is done in a depth-optimal order, and relinearization is performed automatically after every multiplication in the process. In relinearization the given relinearization keys are used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to exponentiate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exponent</td><td>The power to raise the ciphertext to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relin_keys</td><td>The relinearization keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if scheme is not scheme_type::BFV </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted or relin_keys is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not in the default NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if, when using scheme_type::CKKS, the output scale is too large for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if exponent is zero </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the size of relin_keys is too small </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e603dbfcd7e26ecf6eaa746d6fbac50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e603dbfcd7e26ecf6eaa746d6fbac50">&#9670;&nbsp;</a></span>mod_switch_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::mod_switch_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parms_id_type&#160;</td>
          <td class="paramname"><em>parms_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a ciphertext encrypted modulo q_1...q_k, this function switches the modulus down until the parameters reach the given parms_id and stores the result in the destination parameter. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to be switched to a smaller modulus </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parms_id</td><td>The target parms_id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the modulus switched result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not in the default NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if parms_id is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is already at lower level in modulus chain than the parameters corresponding to parms_id </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if, when using scheme_type::CKKS, the scale is too large for the new encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad87e03471a8a1e7c2214f9cfc91c0258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad87e03471a8a1e7c2214f9cfc91c0258">&#9670;&nbsp;</a></span>mod_switch_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::mod_switch_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parms_id_type&#160;</td>
          <td class="paramname"><em>parms_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given an NTT transformed plaintext modulo q_1...q_k, this function switches the modulus down until the parameters reach the given parms_id and stores the result in the destination parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>The plaintext to be switched to a smaller modulus </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parms_id</td><td>The target parms_id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The plaintext to overwrite with the modulus switched result </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if plain is not in NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if plain is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if parms_id is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if plain is already at lower level in modulus chain than the parameters corresponding to parms_id </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if, when using scheme_type::CKKS, the scale is too large for the new encryption parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb372ae05b05d3524093e607ee4f382d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb372ae05b05d3524093e607ee4f382d">&#9670;&nbsp;</a></span>mod_switch_to_inplace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::mod_switch_to_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parms_id_type&#160;</td>
          <td class="paramname"><em>parms_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a ciphertext encrypted modulo q_1...q_k, this function switches the modulus down until the parameters reach the given parms_id. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to be switched to a smaller modulus </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parms_id</td><td>The target parms_id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not in the default NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if parms_id is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is already at lower level in modulus chain than the parameters corresponding to parms_id </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted has size larger than 2 </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if, when using scheme_type::CKKS, the scale is too large for the new encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1193dae509bf5b1effab1afdc1b1d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1193dae509bf5b1effab1afdc1b1d0e">&#9670;&nbsp;</a></span>mod_switch_to_inplace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::mod_switch_to_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parms_id_type&#160;</td>
          <td class="paramname"><em>parms_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an NTT transformed plaintext modulo q_1...q_k, this function switches the modulus down until the parameters reach the given parms_id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>The plaintext to be switched to a smaller modulus </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parms_id</td><td>The target parms_id </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if plain is not in NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if plain is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if parms_id is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if plain is already at lower level in modulus chain than the parameters corresponding to parms_id </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if, when using scheme_type::CKKS, the scale is too large for the new encryption parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23f13048686ae44b508bcbd467bac627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f13048686ae44b508bcbd467bac627">&#9670;&nbsp;</a></span>mod_switch_to_next() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::mod_switch_to_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a ciphertext encrypted modulo q_1...q_k, this function switches the modulus down to q_1...q_{k-1} and stores the result in the destination parameter. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to be switched to a smaller modulus </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the modulus switched result </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not in the default NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is already at lowest level </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted has size larger than 2 </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if, when using scheme_type::CKKS, the scale is too large for the new encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a821eaf26522d2544ef76826ad1dcc4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821eaf26522d2544ef76826ad1dcc4df">&#9670;&nbsp;</a></span>mod_switch_to_next() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::mod_switch_to_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Modulus switches an NTT transformed plaintext from modulo q_1...q_k down to modulo q_1...q_{k-1} and stores the result in the destination parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>The plaintext to be switched to a smaller modulus </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The plaintext to overwrite with the modulus switched result </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if plain is not in NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if plain is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if plain is already at lowest level </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if, when using scheme_type::CKKS, the scale is too large for the new encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09f9a3adef2f00526fc7ffa02c32a5c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f9a3adef2f00526fc7ffa02c32a5c9">&#9670;&nbsp;</a></span>mod_switch_to_next_inplace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::mod_switch_to_next_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a ciphertext encrypted modulo q_1...q_k, this function switches the modulus down to q_1...q_{k-1}. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to be switched to a smaller modulus </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not in the default NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is already at lowest level </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted has size larger than 2 </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if, when using scheme_type::CKKS, the scale is too large for the new encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af89e2b0e74e7b5cd3d4a1d7923ec19e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af89e2b0e74e7b5cd3d4a1d7923ec19e8">&#9670;&nbsp;</a></span>mod_switch_to_next_inplace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::mod_switch_to_next_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Modulus switches an NTT transformed plaintext from modulo q_1...q_k down to modulo q_1...q_{k-1}.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>The plaintext to be switched to a smaller modulus </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if plain is not in NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if plain is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if plain is already at lowest level </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if, when using scheme_type::CKKS, the scale is too large for the new encryption parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9131f149deb68c99640d790529a1db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9131f149deb68c99640d790529a1db4">&#9670;&nbsp;</a></span>multiply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies two ciphertexts. This functions computes the product of encrypted1 and encrypted2 and stores the result in the destination parameter. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted1</td><td>The first ciphertext to multiply </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted2</td><td>The second ciphertext to multiply </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the multiplication result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted1 or encrypted2 is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted1 or encrypted2 is not in the default NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if, when using scheme_type::CKKS, the output scale is too large for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80a270c40a06e75d44443a4ca74dccc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a270c40a06e75d44443a4ca74dccc4">&#9670;&nbsp;</a></span>multiply_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::multiply_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplies two ciphertexts. This functions computes the product of encrypted1 and encrypted2 and stores the result in encrypted1. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted1</td><td>The first ciphertext to multiply </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted2</td><td>The second ciphertext to multiply </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted1 or encrypted2 is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted1 or encrypted2 is not in the default NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if, when using scheme_type::CKKS, the output scale is too large for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6fad97d58e0547e7839a7e92c5b2a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6fad97d58e0547e7839a7e92c5b2a25">&#9670;&nbsp;</a></span>multiply_many()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::multiply_many </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>encrypteds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1RelinKeys.html">RelinKeys</a> &amp;&#160;</td>
          <td class="paramname"><em>relin_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplies several ciphertexts together. This function computes the product of several ciphertext given as an std::vector and stores the result in the destination parameter. The multiplication is done in a depth-optimal order, and relinearization is performed automatically after every multiplication in the process. In relinearization the given relinearization keys are used. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypteds</td><td>The ciphertexts to multiply </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relin_keys</td><td>The relinearization keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the multiplication result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if scheme is not scheme_type::BFV </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypteds is empty </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the ciphertexts or relin_keys are not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypteds are not in the default NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if, when using scheme_type::CKKS, the output scale is too large for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the size of relin_keys is too small </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7abfa74a172611ff3074bc035e4c4cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7abfa74a172611ff3074bc035e4c4cb9">&#9670;&nbsp;</a></span>multiply_plain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::multiply_plain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies a ciphertext with a plaintext. This function multiplies a ciphertext with a plaintext and stores the result in the destination parameter. The plaintext must be a valid for the current encryption parameters, and cannot be identially 0. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to multiply </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>The plaintext to multiply </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the multiplication result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the encrypted or plain is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted and plain are in different NTT forms </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if plain is zero </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if, when using scheme_type::CKKS, the output scale is too large for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a0dba483435b810b33ede2ffadd3ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0dba483435b810b33ede2ffadd3ca8">&#9670;&nbsp;</a></span>multiply_plain_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::multiply_plain_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplies a ciphertext with a plaintext. The plaintext must be valid for the current encryption parameters, and cannot be identially 0. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to multiply </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>The plaintext to multiply </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the encrypted or plain is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted and plain are in different NTT forms </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if, when using scheme_type::CKKS, the output scale is too large for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adafff833b8482769435ea25cd814af55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adafff833b8482769435ea25cd814af55">&#9670;&nbsp;</a></span>negate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::negate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Negates a ciphertext and stores the result in the destination parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to negate </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the negated result </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae58ba00f7da21a487a53be509053a8ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58ba00f7da21a487a53be509053a8ee">&#9670;&nbsp;</a></span>negate_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::negate_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Negates a ciphertext.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to negate </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not valid for the encryption parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2991b74a5535eb5951e359e209eeeb6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2991b74a5535eb5951e359e209eeeb6f">&#9670;&nbsp;</a></span>relinearize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::relinearize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1RelinKeys.html">RelinKeys</a> &amp;&#160;</td>
          <td class="paramname"><em>relin_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Relinearizes a ciphertext. This functions relinearizes encrypted, reducing its size down to 2, and stores the result in the destination parameter. If the size of encrypted is K+1, the given relinearization keys need to have size at least K-1. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to relinearize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relin_keys</td><td>The relinearization keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the relinearized result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted or relin_keys is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not in the default NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if relin_keys do not correspond to the top level parameters in the current context </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the size of relin_keys is too small </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a526a3da5daab4a2bed366bde3af23fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526a3da5daab4a2bed366bde3af23fa3">&#9670;&nbsp;</a></span>relinearize_inplace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::relinearize_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1RelinKeys.html">RelinKeys</a> &amp;&#160;</td>
          <td class="paramname"><em>relin_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Relinearizes a ciphertext. This functions relinearizes encrypted, reducing its size down to 2. If the size of encrypted is K+1, the given relinearization keys need to have size at least K-1. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to relinearize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relin_keys</td><td>The relinearization keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted or relin_keys is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not in the default NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if relin_keys do not correspond to the top level parameters in the current context </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the size of relin_keys is too small </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47bafd672948e8c9b8550327bdcbb930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47bafd672948e8c9b8550327bdcbb930">&#9670;&nbsp;</a></span>rescale_to()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::rescale_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parms_id_type&#160;</td>
          <td class="paramname"><em>parms_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a ciphertext encrypted modulo q_1...q_k, this function switches the modulus down until the parameters reach the given parms_id, scales the message down accordingly, and stores the result in the destination parameter. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to be switched to a smaller modulus </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parms_id</td><td>The target parms_id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the modulus switched result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the scheme is invalid for rescaling </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not in the default NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if parms_id is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is already at lower level in modulus chain than the parameters corresponding to parms_id </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted has size larger than 2 </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae347aebd276af11671803e67efdcad05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae347aebd276af11671803e67efdcad05">&#9670;&nbsp;</a></span>rescale_to_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::rescale_to_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parms_id_type&#160;</td>
          <td class="paramname"><em>parms_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a ciphertext encrypted modulo q_1...q_k, this function switches the modulus down until the parameters reach the given parms_id and scales the message down accordingly. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to be switched to a smaller modulus </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parms_id</td><td>The target parms_id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the scheme is invalid for rescaling </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not in the default NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if parms_id is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is already at lower level in modulus chain than the parameters corresponding to parms_id </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted has size larger than 2 </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acee79b403a31f0b24d587063303129e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee79b403a31f0b24d587063303129e7">&#9670;&nbsp;</a></span>rescale_to_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::rescale_to_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a ciphertext encrypted modulo q_1...q_k, this function switches the modulus down to q_1...q_{k-1}, scales the message down accordingly, and stores the result in the destination parameter. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to be switched to a smaller modulus </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the modulus switched result </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the scheme is invalid for rescaling </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not in the default NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is already at lowest level </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted has size larger than 2 </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa075f8db976da32643c1d6c663215a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa075f8db976da32643c1d6c663215a32">&#9670;&nbsp;</a></span>rescale_to_next_inplace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::rescale_to_next_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a ciphertext encrypted modulo q_1...q_k, this function switches the modulus down to q_1...q_{k-1} and scales the message down accordingly. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to be switched to a smaller modulus </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the scheme is invalid for rescaling </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not in the default NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is already at lowest level </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted has size larger than 2 </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7340b8eb509b787ef8c706e3e657adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7340b8eb509b787ef8c706e3e657adf">&#9670;&nbsp;</a></span>rotate_columns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::rotate_columns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1GaloisKeys.html">GaloisKeys</a> &amp;&#160;</td>
          <td class="paramname"><em>galois_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rotates plaintext matrix columns cyclically. When batching is used with the BFV scheme, this function rotates the encrypted plaintext matrix columns cyclically, and writes the result to the destination parameter. Since the size of the batched matrix is 2-by-(N/2), where N is the degree of the polynomial modulus, this means simply swapping the two rows. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to rotate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">galois_keys</td><td>The Galois keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the rotated result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if scheme is not scheme_type::BFV </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the encryption parameters do not support batching </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted or galois_keys is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if galois_keys do not correspond to the top level parameters in the current context </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is in NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted has size larger than 2 </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if necessary Galois keys are not present </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3de4e73e74186dc3b7e6c3a3545b95d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de4e73e74186dc3b7e6c3a3545b95d0">&#9670;&nbsp;</a></span>rotate_columns_inplace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::rotate_columns_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1GaloisKeys.html">GaloisKeys</a> &amp;&#160;</td>
          <td class="paramname"><em>galois_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rotates plaintext matrix columns cyclically. When batching is used with the BFV scheme, this function rotates the encrypted plaintext matrix columns cyclically. Since the size of the batched matrix is 2-by-(N/2), where N is the degree of the polynomial modulus, this means simply swapping the two rows. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to rotate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">galois_keys</td><td>The Galois keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the rotated result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if scheme is not scheme_type::BFV </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the encryption parameters do not support batching </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted or galois_keys is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if galois_keys do not correspond to the top level parameters in the current context </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is in NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted has size larger than 2 </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if necessary Galois keys are not present </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa7c73d2903d4afae7969340c8d3c21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7c73d2903d4afae7969340c8d3c21c">&#9670;&nbsp;</a></span>rotate_rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::rotate_rows </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1GaloisKeys.html">GaloisKeys</a> &amp;&#160;</td>
          <td class="paramname"><em>galois_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rotates plaintext matrix rows cyclically. When batching is used with the BFV scheme, this function rotates the encrypted plaintext matrix rows cyclically to the left (steps &gt; 0) or to the right (steps &lt; 0) and writes the result to the destination parameter. Since the size of the batched matrix is 2-by-(N/2), where N is the degree of the polynomial modulus, the number of steps to rotate must have absolute value at most N/2-1. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to rotate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">steps</td><td>The number of steps to rotate (negative left, positive right) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">galois_keys</td><td>The Galois keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the rotated result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if scheme is not scheme_type::BFV </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the encryption parameters do not support batching </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted or galois_keys is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if galois_keys do not correspond to the top level parameters in the current context </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is in NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted has size larger than 2 </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if steps has too big absolute value </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if necessary Galois keys are not present </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f3447cb7bd61c93b2c37b7216071725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3447cb7bd61c93b2c37b7216071725">&#9670;&nbsp;</a></span>rotate_rows_inplace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::rotate_rows_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1GaloisKeys.html">GaloisKeys</a> &amp;&#160;</td>
          <td class="paramname"><em>galois_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rotates plaintext matrix rows cyclically. When batching is used with the BFV scheme, this function rotates the encrypted plaintext matrix rows cyclically to the left (steps &gt; 0) or to the right (steps &lt; 0). Since the size of the batched matrix is 2-by-(N/2), where N is the degree of the polynomial modulus, the number of steps to rotate must have absolute value at most N/2-1. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to rotate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">steps</td><td>The number of steps to rotate (negative left, positive right) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">galois_keys</td><td>The Galois keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if scheme is not scheme_type::BFV </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the encryption parameters do not support batching </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted or galois_keys is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if galois_keys do not correspond to the top level parameters in the current context </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not in the default NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted has size larger than 2 </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if steps has too big absolute value </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if necessary Galois keys are not present </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a164b7b937cbb21a139ab0413f7e22612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164b7b937cbb21a139ab0413f7e22612">&#9670;&nbsp;</a></span>rotate_vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::rotate_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1GaloisKeys.html">GaloisKeys</a> &amp;&#160;</td>
          <td class="paramname"><em>galois_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rotates plaintext vector cyclically. When using the CKKS scheme, this function rotates the encrypted plaintext vector cyclically to the left (steps &gt; 0) or to the right (steps &lt; 0) and writes the result to the destination parameter. Since the size of the batched matrix is 2-by-(N/2), where N is the degree of the polynomial modulus, the number of steps to rotate must have absolute value at most N/2-1. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to rotate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">steps</td><td>The number of steps to rotate (negative left, positive right) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">galois_keys</td><td>The Galois keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the rotated result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if scheme is not scheme_type::CKKS </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted or galois_keys is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if galois_keys do not correspond to the top level parameters in the current context </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is in NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted has size larger than 2 </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if steps has too big absolute value </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if necessary Galois keys are not present </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf21800889afc62f8b733391602e6b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf21800889afc62f8b733391602e6b57">&#9670;&nbsp;</a></span>rotate_vector_inplace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::rotate_vector_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1GaloisKeys.html">GaloisKeys</a> &amp;&#160;</td>
          <td class="paramname"><em>galois_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rotates plaintext vector cyclically. When using the CKKS scheme, this function rotates the encrypted plaintext vector cyclically to the left (steps &gt; 0) or to the right (steps &lt; 0). Since the size of the batched matrix is 2-by-(N/2), where N is the degree of the polynomial modulus, the number of steps to rotate must have absolute value at most N/2-1. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to rotate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">steps</td><td>The number of steps to rotate (negative left, positive right) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">galois_keys</td><td>The Galois keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if scheme is not scheme_type::CKKS </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted or galois_keys is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if galois_keys do not correspond to the top level parameters in the current context </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not in the default NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted has size larger than 2 </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if steps has too big absolute value </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if necessary Galois keys are not present </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba6ce5aa2b92e9b97db346f91dd39e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba6ce5aa2b92e9b97db346f91dd39e92">&#9670;&nbsp;</a></span>square()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::square </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Squares a ciphertext. This functions computes the square of encrypted and stores the result in the destination parameter. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to square </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the square </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not in the default NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if, when using scheme_type::CKKS, the output scale is too large for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f13bfd3e06b4f85b6e8f494e76becee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f13bfd3e06b4f85b6e8f494e76becee">&#9670;&nbsp;</a></span>square_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::square_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Squares a ciphertext. This functions computes the square of encrypted. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to square </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not in the default NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if, when using scheme_type::CKKS, the output scale is too large for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5e89e02a7a60ee15bc544966e48cf82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e89e02a7a60ee15bc544966e48cf82">&#9670;&nbsp;</a></span>sub()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtracts two ciphertexts. This function computes the difference of encrypted1 and encrypted2 and stores the result in the destination parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted1</td><td>The ciphertext to subtract from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted2</td><td>The ciphertext to subtract </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the subtraction result </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted1 or encrypted2 is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted1 and encrypted2 are in different NTT forms </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted1 and encrypted2 have different scale </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49952ff145ce3f1b2e13f9cdee3ca6ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49952ff145ce3f1b2e13f9cdee3ca6ec">&#9670;&nbsp;</a></span>sub_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::sub_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtracts two ciphertexts. This function computes the difference of encrypted1 and encrypted2, and stores the result in encrypted1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted1</td><td>The ciphertext to subtract from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted2</td><td>The ciphertext to subtract </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted1 or encrypted2 is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted1 and encrypted2 are in different NTT forms </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted1 and encrypted2 have different scale </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e3fe78f97051e39a44d35d20fe1e618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3fe78f97051e39a44d35d20fe1e618">&#9670;&nbsp;</a></span>sub_plain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::sub_plain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtracts a plaintext from a ciphertext. This function subtracts a plaintext from a ciphertext and stores the result in the destination parameter. The plaintext must be valid for the current encryption parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to subtract from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>The plaintext to subtract </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the subtraction result </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted or plain is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted or plain is in NTT form </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac28cdbf1304d001bdcc5e6ca33c7462f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28cdbf1304d001bdcc5e6ca33c7462f">&#9670;&nbsp;</a></span>sub_plain_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::sub_plain_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtracts a plaintext from a ciphertext. The plaintext must be valid for the current encryption parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to subtract from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>The plaintext to subtract </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted or plain is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted or plain is in NTT form </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b4b08d357b06baa53036a087799dc10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b4b08d357b06baa53036a087799dc10">&#9670;&nbsp;</a></span>transform_from_ntt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::transform_from_ntt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted_ntt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transforms a ciphertext back from NTT domain. This functions applies the inverse of David Harvey's Number Theoretic Transform separately to each polynomial of a ciphertext. The result is stored in the destination parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted_ntt</td><td>The ciphertext to transform </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the transformed result </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted_ntt is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted_ntt is not in NTT form </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bb91aa496134803abd084a1307041b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb91aa496134803abd084a1307041b3">&#9670;&nbsp;</a></span>transform_from_ntt_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::transform_from_ntt_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted_ntt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transforms a ciphertext back from NTT domain. This functions applies the inverse of David Harvey's Number Theoretic Transform separately to each polynomial of a ciphertext.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted_ntt</td><td>The ciphertext to transform </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted_ntt is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted_ntt is not in NTT form </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2d69437cb36e358bd9ca53c76a9d7be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d69437cb36e358bd9ca53c76a9d7be">&#9670;&nbsp;</a></span>transform_to_ntt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::transform_to_ntt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parms_id_type&#160;</td>
          <td class="paramname"><em>parms_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination_ntt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transforms a plaintext to NTT domain. This functions applies the Number Theoretic Transform to a plaintext by first embedding integers modulo the plaintext modulus to integers modulo the coefficient modulus and then performing David Harvey's NTT on the resulting polynomial. The transformation is done with respect to encryption parameters corresponding to a given parms_id. The result is stored in the destination_ntt parameter. For the operation to be valid, the plaintext must have degree less than poly_modulus_degree and each coefficient must be less than the plaintext modulus, i.e. the plaintext must be a valid plaintext under the current encryption parameters. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>The plaintext to transform </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parms_id</td><td>The parms_id with respect to which the NTT is done </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destinationNTT</td><td>The plaintext to overwrite with the transformed result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if plain is already in NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if plain or parms_id is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a969fc02ff4f26b7ec09faeed550302ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a969fc02ff4f26b7ec09faeed550302ed">&#9670;&nbsp;</a></span>transform_to_ntt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::transform_to_ntt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination_ntt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transforms a ciphertext to NTT domain. This functions applies David Harvey's Number Theoretic Transform separately to each polynomial of a ciphertext. The result is stored in the destination_ntt parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to transform </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination_ntt</td><td>The ciphertext to overwrite with the transformed result </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is already in NTT form </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8845e9d44668045c3d5721babe69c172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8845e9d44668045c3d5721babe69c172">&#9670;&nbsp;</a></span>transform_to_ntt_inplace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::transform_to_ntt_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parms_id_type&#160;</td>
          <td class="paramname"><em>parms_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a6a958675107433f09c0ecbfd80197355">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transforms a plaintext to NTT domain. This functions applies the Number Theoretic Transform to a plaintext by first embedding integers modulo the plaintext modulus to integers modulo the coefficient modulus and then performing David Harvey's NTT on the resulting polynomial. The transformation is done with respect to encryption parameters corresponding to a given parms_id. For the operation to be valid, the plaintext must have degree less than poly_modulus_degree and each coefficient must be less than the plaintext modulus, i.e. the plaintext must be a valid plaintext under the current encryption parameters. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>The plaintext to transform </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parms_id</td><td>The parms_id with respect to which the NTT is done </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if plain is already in NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if plain or parms_id is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f8daf73494c4849bfa6740256e8c856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f8daf73494c4849bfa6740256e8c856">&#9670;&nbsp;</a></span>transform_to_ntt_inplace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Evaluator::transform_to_ntt_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>encrypted</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transforms a ciphertext to NTT domain. This functions applies David Harvey's Number Theoretic Transform separately to each polynomial of a ciphertext.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encrypted</td><td>The ciphertext to transform </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encrypted is already in NTT form </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if result ciphertext is transparent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>seal/<a class="el" href="evaluator_8h_source.html">evaluator.h</a></li>
<li>seal/evaluator.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
