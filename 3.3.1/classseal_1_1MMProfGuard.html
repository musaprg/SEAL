<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEAL: seal::MMProfGuard Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SEAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>seal</b></li><li class="navelem"><a class="el" href="classseal_1_1MMProfGuard.html">MMProfGuard</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classseal_1_1MMProfGuard-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">seal::MMProfGuard Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="memorymanager_8h_source.html">memorymanager.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a54f489c658042be2dd361f2fa8d5be91"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1MMProfGuard.html#a54f489c658042be2dd361f2fa8d5be91">MMProfGuard</a> (std::unique_ptr&lt; <a class="el" href="classseal_1_1MMProf.html">MMProf</a> &gt; &amp;&amp;mm_prof, bool start_locked=true) noexcept</td></tr>
<tr class="separator:a54f489c658042be2dd361f2fa8d5be91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ffc9fe20308a85d54c0d7842daf6d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1MMProfGuard.html#a09ffc9fe20308a85d54c0d7842daf6d6">MMProfGuard</a> (<a class="el" href="classseal_1_1MMProf.html">MMProf</a> *&amp;&amp;mm_prof, bool start_locked=true) noexcept</td></tr>
<tr class="separator:a09ffc9fe20308a85d54c0d7842daf6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d47820ee3b0633c6b6a8987a8b264b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1MMProfGuard.html#a6d47820ee3b0633c6b6a8987a8b264b7">try_lock</a> ()</td></tr>
<tr class="separator:a6d47820ee3b0633c6b6a8987a8b264b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5211c21bfd6e81ff2f505577882a5bce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1MMProfGuard.html#a5211c21bfd6e81ff2f505577882a5bce">lock</a> ()</td></tr>
<tr class="separator:a5211c21bfd6e81ff2f505577882a5bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd7224043ab6dcbd24185fb2d3e8f12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1MMProfGuard.html#a1bd7224043ab6dcbd24185fb2d3e8f12">try_lock</a> (std::unique_ptr&lt; <a class="el" href="classseal_1_1MMProf.html">MMProf</a> &gt; &amp;&amp;mm_prof)</td></tr>
<tr class="separator:a1bd7224043ab6dcbd24185fb2d3e8f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca5f1d74ae2a567d35fa391a94477e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1MMProfGuard.html#a9ca5f1d74ae2a567d35fa391a94477e4">lock</a> (std::unique_ptr&lt; <a class="el" href="classseal_1_1MMProf.html">MMProf</a> &gt; &amp;&amp;mm_prof)</td></tr>
<tr class="separator:a9ca5f1d74ae2a567d35fa391a94477e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008f383751a5778cd877ab5d9db8d890"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1MMProfGuard.html#a008f383751a5778cd877ab5d9db8d890">try_lock</a> (<a class="el" href="classseal_1_1MMProf.html">MMProf</a> *&amp;&amp;mm_prof)</td></tr>
<tr class="separator:a008f383751a5778cd877ab5d9db8d890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09558e9ee30814f51099df0668d764de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1MMProfGuard.html#a09558e9ee30814f51099df0668d764de">lock</a> (<a class="el" href="classseal_1_1MMProf.html">MMProf</a> *&amp;&amp;mm_prof)</td></tr>
<tr class="separator:a09558e9ee30814f51099df0668d764de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940a3f4bf56565129313e7f2921f7266"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1MMProfGuard.html#a940a3f4bf56565129313e7f2921f7266">unlock</a> ()</td></tr>
<tr class="separator:a940a3f4bf56565129313e7f2921f7266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73cbf7f0be45a91e6fd825c49dd56547"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1MMProfGuard.html#a73cbf7f0be45a91e6fd825c49dd56547">~MMProfGuard</a> ()</td></tr>
<tr class="separator:a73cbf7f0be45a91e6fd825c49dd56547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7164b4c0d7d469ea17eaa5124024f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1MMProfGuard.html#acb7164b4c0d7d469ea17eaa5124024f9">owns_lock</a> () noexcept</td></tr>
<tr class="separator:acb7164b4c0d7d469ea17eaa5124024f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for a scoped switch of memory manager profile. This class acts as a scoped "guard" for changing the memory manager profile so that the programmer does not have to explicitly switch back afterwards and that other threads cannot change the <a class="el" href="classseal_1_1MMProf.html">MMProf</a>. It can also help with exception safety by guaranteeing that the profile is switched back to the original if a function throws an exception after changing the profile for local use. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a54f489c658042be2dd361f2fa8d5be91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f489c658042be2dd361f2fa8d5be91">&#9670;&nbsp;</a></span>MMProfGuard() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">seal::MMProfGuard::MMProfGuard </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classseal_1_1MMProf.html">MMProf</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>mm_prof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>start_locked</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new <a class="el" href="classseal_1_1MMProfGuard.html">MMProfGuard</a>. If start_locked is true, this function will attempt to lock the <a class="el" href="classseal_1_1MemoryManager.html">MemoryManager</a> for profile switch to mm_prof, perform the switch, and keep the lock until unlocked or destroyed. If start_lock is false, mm_prof will be stored but the switch will not be performed and a lock will not be obtained until <a class="el" href="classseal_1_1MMProfGuard.html#a5211c21bfd6e81ff2f505577882a5bce">lock()</a> is explicitly called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm_prof</td><td>Pointer to a new memory manager profile </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_locked</td><td>Bool indicating whether the lock should be immediately obtained (true by default) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09ffc9fe20308a85d54c0d7842daf6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ffc9fe20308a85d54c0d7842daf6d6">&#9670;&nbsp;</a></span>MMProfGuard() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">seal::MMProfGuard::MMProfGuard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1MMProf.html">MMProf</a> *&amp;&amp;&#160;</td>
          <td class="paramname"><em>mm_prof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>start_locked</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new <a class="el" href="classseal_1_1MMProfGuard.html">MMProfGuard</a>. If start_locked is true, this function will attempt to lock the <a class="el" href="classseal_1_1MemoryManager.html">MemoryManager</a> for profile switch to mm_prof, perform the switch, and keep the lock until unlocked or destroyed. If start_lock is false, mm_prof will be stored but the switch will not be performed and a lock will not be obtained until <a class="el" href="classseal_1_1MMProfGuard.html#a5211c21bfd6e81ff2f505577882a5bce">lock()</a> is explicitly called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm_prof</td><td>Pointer to a new memory manager profile </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_locked</td><td>Bool indicating whether the lock should be immediately obtained (true by default) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73cbf7f0be45a91e6fd825c49dd56547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73cbf7f0be45a91e6fd825c49dd56547">&#9670;&nbsp;</a></span>~MMProfGuard()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">seal::MMProfGuard::~MMProfGuard </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroys the <a class="el" href="classseal_1_1MMProfGuard.html">MMProfGuard</a>. If the memory manager profile switch lock is owned, releases the lock, and resets the profile to the one used before locking. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5211c21bfd6e81ff2f505577882a5bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5211c21bfd6e81ff2f505577882a5bce">&#9670;&nbsp;</a></span>lock() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::MMProfGuard::lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Locks the <a class="el" href="classseal_1_1MemoryManager.html">MemoryManager</a> for profile switch, performs the switch to currently stored memory manager profile, stores the previously held profile, and keep the lock until unlocked or destroyed. The calling thread will block until the lock can be obtained.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the lock is already owned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ca5f1d74ae2a567d35fa391a94477e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca5f1d74ae2a567d35fa391a94477e4">&#9670;&nbsp;</a></span>lock() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::MMProfGuard::lock </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classseal_1_1MMProf.html">MMProf</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>mm_prof</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Locks the <a class="el" href="classseal_1_1MemoryManager.html">MemoryManager</a> for profile switch, performs the switch to the given memory manager profile, stores the previously held profile, and keep the lock until unlocked or destroyed. The calling thread will block until the lock can be obtained.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm_prof</td><td>Pointer to a new memory manager profile </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the lock is already owned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09558e9ee30814f51099df0668d764de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09558e9ee30814f51099df0668d764de">&#9670;&nbsp;</a></span>lock() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::MMProfGuard::lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1MMProf.html">MMProf</a> *&amp;&amp;&#160;</td>
          <td class="paramname"><em>mm_prof</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Locks the <a class="el" href="classseal_1_1MemoryManager.html">MemoryManager</a> for profile switch, performs the switch to the given memory manager profile, stores the previously held profile, and keep the lock until unlocked or destroyed. The calling thread will block until the lock can be obtained.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm_prof</td><td>Pointer to a new memory manager profile </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the lock is already owned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb7164b4c0d7d469ea17eaa5124024f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7164b4c0d7d469ea17eaa5124024f9">&#9670;&nbsp;</a></span>owns_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool seal::MMProfGuard::owns_lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the current <a class="el" href="classseal_1_1MMProfGuard.html">MMProfGuard</a> owns the memory manager profile switch lock. </p>

</div>
</div>
<a id="a6d47820ee3b0633c6b6a8987a8b264b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d47820ee3b0633c6b6a8987a8b264b7">&#9670;&nbsp;</a></span>try_lock() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool seal::MMProfGuard::try_lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempts to lock the <a class="el" href="classseal_1_1MemoryManager.html">MemoryManager</a> for profile switch, perform the switch to currently stored memory manager profile, store the previously held profile, and keep the lock until unlocked or destroyed. If the lock cannot be obtained on the first attempt, the function returns false; otherwise returns true.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the lock is already owned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bd7224043ab6dcbd24185fb2d3e8f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd7224043ab6dcbd24185fb2d3e8f12">&#9670;&nbsp;</a></span>try_lock() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool seal::MMProfGuard::try_lock </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classseal_1_1MMProf.html">MMProf</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>mm_prof</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempts to lock the <a class="el" href="classseal_1_1MemoryManager.html">MemoryManager</a> for profile switch, perform the switch to the given memory manager profile, store the previously held profile, and keep the lock until unlocked or destroyed. If the lock cannot be obtained on the first attempt, the function returns false; otherwise returns true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm_prof</td><td>Pointer to a new memory manager profile </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the lock is already owned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a008f383751a5778cd877ab5d9db8d890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008f383751a5778cd877ab5d9db8d890">&#9670;&nbsp;</a></span>try_lock() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool seal::MMProfGuard::try_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1MMProf.html">MMProf</a> *&amp;&amp;&#160;</td>
          <td class="paramname"><em>mm_prof</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempts to lock the <a class="el" href="classseal_1_1MemoryManager.html">MemoryManager</a> for profile switch, perform the switch to the given memory manager profile, store the previously held profile, and keep the lock until unlocked or destroyed. If the lock cannot be obtained on the first attempt, the function returns false; otherwise returns true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mm_prof</td><td>Pointer to a new memory manager profile </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the lock is already owned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a940a3f4bf56565129313e7f2921f7266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940a3f4bf56565129313e7f2921f7266">&#9670;&nbsp;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::MMProfGuard::unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Releases the memory manager profile switch lock for <a class="el" href="classseal_1_1MemoryManager.html">MemoryManager</a>, stores the current profile, and resets the profile to the one used before locking.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the lock is not owned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>seal/<a class="el" href="memorymanager_8h_source.html">memorymanager.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
