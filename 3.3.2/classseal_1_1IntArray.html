<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEAL: seal::IntArray&lt; T_, typename &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SEAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>seal</b></li><li class="navelem"><a class="el" href="classseal_1_1IntArray.html">IntArray</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classseal_1_1IntArray-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">seal::IntArray&lt; T_, typename &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="intarray_8h_source.html">intarray.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ade8f5099df8268188d31e03ca45dfb86"><td class="memItemLeft" align="right" valign="top"><a id="ade8f5099df8268188d31e03ca45dfb86"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = std::size_t</td></tr>
<tr class="separator:ade8f5099df8268188d31e03ca45dfb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24eeb96082ab22dd81c20715b57418db"><td class="memItemLeft" align="right" valign="top"><a id="a24eeb96082ab22dd81c20715b57418db"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>T</b> = typename std::decay&lt; T_ &gt;::type</td></tr>
<tr class="separator:a24eeb96082ab22dd81c20715b57418db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1a951a122a3f59a1ad9721c1a8daeb8c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1IntArray.html#a1a951a122a3f59a1ad9721c1a8daeb8c">IntArray</a> (<a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> <a class="el" href="classseal_1_1IntArray.html#adac37d01c2640d99d8ee367cb6c5c275">pool</a>=<a class="el" href="classseal_1_1MemoryManager.html#a15a7acfaa035f60df37b73e6f55d0937">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:a1a951a122a3f59a1ad9721c1a8daeb8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7013a0cfa0a4561e8031401f63e8452b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1IntArray.html#a7013a0cfa0a4561e8031401f63e8452b">IntArray</a> (size_type <a class="el" href="classseal_1_1IntArray.html#a7555aca03cbd60d3911dc641228949eb">size</a>, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> <a class="el" href="classseal_1_1IntArray.html#adac37d01c2640d99d8ee367cb6c5c275">pool</a>=<a class="el" href="classseal_1_1MemoryManager.html#a15a7acfaa035f60df37b73e6f55d0937">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:a7013a0cfa0a4561e8031401f63e8452b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e730f8c17dfe807653f7201fc495f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1IntArray.html#ac0e730f8c17dfe807653f7201fc495f5">IntArray</a> (size_type <a class="el" href="classseal_1_1IntArray.html#a193ec07b466a83467217b81a90f6063d">capacity</a>, size_type <a class="el" href="classseal_1_1IntArray.html#a7555aca03cbd60d3911dc641228949eb">size</a>, <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> <a class="el" href="classseal_1_1IntArray.html#adac37d01c2640d99d8ee367cb6c5c275">pool</a>=<a class="el" href="classseal_1_1MemoryManager.html#a15a7acfaa035f60df37b73e6f55d0937">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:ac0e730f8c17dfe807653f7201fc495f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1fdfbdfb701a5c560b315dedab77cdf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1IntArray.html#ad1fdfbdfb701a5c560b315dedab77cdf">IntArray</a> (const <a class="el" href="classseal_1_1IntArray.html">IntArray</a>&lt; T &gt; &amp;copy)</td></tr>
<tr class="separator:ad1fdfbdfb701a5c560b315dedab77cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7b42e48e2123a6a4ed9bf3f675eb65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1IntArray.html#a7d7b42e48e2123a6a4ed9bf3f675eb65">IntArray</a> (<a class="el" href="classseal_1_1IntArray.html">IntArray</a>&lt; T &gt; &amp;&amp;source) noexcept</td></tr>
<tr class="separator:a7d7b42e48e2123a6a4ed9bf3f675eb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8de7d43ee9c352feced82070341c308"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1IntArray.html#ab8de7d43ee9c352feced82070341c308">begin</a> () noexcept</td></tr>
<tr class="separator:ab8de7d43ee9c352feced82070341c308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97c5a47b22021a4f756199af68c8ef4"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1IntArray.html#ad97c5a47b22021a4f756199af68c8ef4">cbegin</a> () const noexcept</td></tr>
<tr class="separator:ad97c5a47b22021a4f756199af68c8ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61ab57a81878714bc9e56abb5d72a36"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1IntArray.html#af61ab57a81878714bc9e56abb5d72a36">end</a> () noexcept</td></tr>
<tr class="separator:af61ab57a81878714bc9e56abb5d72a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4ca5dd85b405c9158cb20d4251d9d8"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1IntArray.html#aab4ca5dd85b405c9158cb20d4251d9d8">cend</a> () const noexcept</td></tr>
<tr class="separator:aab4ca5dd85b405c9158cb20d4251d9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f7ad01501e51d63773b58ea9a8484e"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1IntArray.html#a25f7ad01501e51d63773b58ea9a8484e">at</a> (size_type index) const</td></tr>
<tr class="separator:a25f7ad01501e51d63773b58ea9a8484e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4dc307d4afcadf885f55dd15b034016"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1IntArray.html#aa4dc307d4afcadf885f55dd15b034016">at</a> (size_type index)</td></tr>
<tr class="separator:aa4dc307d4afcadf885f55dd15b034016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ef84191dd7df624ed7d1cde180ac0d"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1IntArray.html#a38ef84191dd7df624ed7d1cde180ac0d">operator[]</a> (size_type index) const</td></tr>
<tr class="separator:a38ef84191dd7df624ed7d1cde180ac0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83342d295637419fff4e9958ca451bab"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1IntArray.html#a83342d295637419fff4e9958ca451bab">operator[]</a> (size_type index)</td></tr>
<tr class="separator:a83342d295637419fff4e9958ca451bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf0ba60b8223cf67e1e104a49638302"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1IntArray.html#acaf0ba60b8223cf67e1e104a49638302">empty</a> () const noexcept</td></tr>
<tr class="separator:acaf0ba60b8223cf67e1e104a49638302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af310bf3e59e36430691804b8da56e2df"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1IntArray.html#af310bf3e59e36430691804b8da56e2df">max_size</a> () const noexcept</td></tr>
<tr class="separator:af310bf3e59e36430691804b8da56e2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7555aca03cbd60d3911dc641228949eb"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1IntArray.html#a7555aca03cbd60d3911dc641228949eb">size</a> () const noexcept</td></tr>
<tr class="separator:a7555aca03cbd60d3911dc641228949eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193ec07b466a83467217b81a90f6063d"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1IntArray.html#a193ec07b466a83467217b81a90f6063d">capacity</a> () const noexcept</td></tr>
<tr class="separator:a193ec07b466a83467217b81a90f6063d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac37d01c2640d99d8ee367cb6c5c275"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1IntArray.html#adac37d01c2640d99d8ee367cb6c5c275">pool</a> () const noexcept</td></tr>
<tr class="separator:adac37d01c2640d99d8ee367cb6c5c275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1b6e1cc7376e5c575bd851482246a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1IntArray.html#aca1b6e1cc7376e5c575bd851482246a2">release</a> () noexcept</td></tr>
<tr class="separator:aca1b6e1cc7376e5c575bd851482246a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f60521bd10e519d780618efa4dc6c64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1IntArray.html#a6f60521bd10e519d780618efa4dc6c64">clear</a> () noexcept</td></tr>
<tr class="separator:a6f60521bd10e519d780618efa4dc6c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe80f93120745b91b54cfd6993ba7c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1IntArray.html#a7fe80f93120745b91b54cfd6993ba7c9">reserve</a> (size_type <a class="el" href="classseal_1_1IntArray.html#a193ec07b466a83467217b81a90f6063d">capacity</a>)</td></tr>
<tr class="separator:a7fe80f93120745b91b54cfd6993ba7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a78b37d04ace09bb22dbe1d2340c41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1IntArray.html#a85a78b37d04ace09bb22dbe1d2340c41">shrink_to_fit</a> ()</td></tr>
<tr class="separator:a85a78b37d04ace09bb22dbe1d2340c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af061f0022f82e59dec54ec3c0fe83d6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1IntArray.html#af061f0022f82e59dec54ec3c0fe83d6e">resize</a> (size_type <a class="el" href="classseal_1_1IntArray.html#a7555aca03cbd60d3911dc641228949eb">size</a>)</td></tr>
<tr class="separator:af061f0022f82e59dec54ec3c0fe83d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec296ea7f1acde1de8517655786504c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1IntArray.html">IntArray</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1IntArray.html#acec296ea7f1acde1de8517655786504c">operator=</a> (const <a class="el" href="classseal_1_1IntArray.html">IntArray</a>&lt; T &gt; &amp;assign)</td></tr>
<tr class="separator:acec296ea7f1acde1de8517655786504c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55430c508fffeb110e565b26685f24dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1IntArray.html">IntArray</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1IntArray.html#a55430c508fffeb110e565b26685f24dc">operator=</a> (<a class="el" href="classseal_1_1IntArray.html">IntArray</a>&lt; T &gt; &amp;&amp;assign) noexcept</td></tr>
<tr class="separator:a55430c508fffeb110e565b26685f24dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0551280bc8ce0342b6cd299c7aed97f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1IntArray.html#a0551280bc8ce0342b6cd299c7aed97f5">save</a> (std::ostream &amp;stream) const</td></tr>
<tr class="separator:a0551280bc8ce0342b6cd299c7aed97f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe50b857a18abaa06f48233b6eb20529"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1IntArray.html#afe50b857a18abaa06f48233b6eb20529">load</a> (std::istream &amp;stream)</td></tr>
<tr class="separator:afe50b857a18abaa06f48233b6eb20529"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T_, typename = std::enable_if_t&lt;std::is_integral&lt;T_&gt;::value&gt;&gt;<br />
class seal::IntArray&lt; T_, typename &gt;</h3>

<p>A resizable container for storing an array of integral data types. The allocations are done from a memory pool. The <a class="el" href="classseal_1_1IntArray.html">IntArray</a> class is mainly intended for internal use and provides the underlying data structure for <a class="el" href="classseal_1_1Plaintext.html">Plaintext</a> and <a class="el" href="classseal_1_1Ciphertext.html">Ciphertext</a> classes.</p>
<dl class="section user"><dt>Size and Capacity</dt><dd><a class="el" href="classseal_1_1IntArray.html">IntArray</a> allows the user to pre-allocate memory (capacity) for the array in cases where the array is known to be resized in the future and memory moves are to be avoided at the time of resizing. The size of the <a class="el" href="classseal_1_1IntArray.html">IntArray</a> can never exceed its capacity. The capacity and size can be changed using the reserve and resize functions, respectively.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>In general, reading from <a class="el" href="classseal_1_1IntArray.html">IntArray</a> is thread-safe as long as no other thread is concurrently mutating it. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1a951a122a3f59a1ad9721c1a8daeb8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a951a122a3f59a1ad9721c1a8daeb8c">&#9670;&nbsp;</a></span>IntArray() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_, typename  = std::enable_if_t&lt;std::is_integral&lt;T_&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1IntArray.html">seal::IntArray</a>&lt; T_, typename &gt;::<a class="el" href="classseal_1_1IntArray.html">IntArray</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a15a7acfaa035f60df37b73e6f55d0937">MemoryManager::GetPool</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new <a class="el" href="classseal_1_1IntArray.html">IntArray</a>. No memory is allocated by this constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7013a0cfa0a4561e8031401f63e8452b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7013a0cfa0a4561e8031401f63e8452b">&#9670;&nbsp;</a></span>IntArray() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_, typename  = std::enable_if_t&lt;std::is_integral&lt;T_&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1IntArray.html">seal::IntArray</a>&lt; T_, typename &gt;::<a class="el" href="classseal_1_1IntArray.html">IntArray</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a15a7acfaa035f60df37b73e6f55d0937">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new <a class="el" href="classseal_1_1IntArray.html">IntArray</a> with given size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if size is less than zero </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0e730f8c17dfe807653f7201fc495f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e730f8c17dfe807653f7201fc495f5">&#9670;&nbsp;</a></span>IntArray() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_, typename  = std::enable_if_t&lt;std::is_integral&lt;T_&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1IntArray.html">seal::IntArray</a>&lt; T_, typename &gt;::<a class="el" href="classseal_1_1IntArray.html">IntArray</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1MemoryManager.html#a15a7acfaa035f60df37b73e6f55d0937">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new <a class="el" href="classseal_1_1IntArray.html">IntArray</a> with given capacity and size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>The capacity of the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if capacity is less than size </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if capacity is less than zero </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if size is less than zero </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1fdfbdfb701a5c560b315dedab77cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1fdfbdfb701a5c560b315dedab77cdf">&#9670;&nbsp;</a></span>IntArray() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_, typename  = std::enable_if_t&lt;std::is_integral&lt;T_&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1IntArray.html">seal::IntArray</a>&lt; T_, typename &gt;::<a class="el" href="classseal_1_1IntArray.html">IntArray</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1IntArray.html">IntArray</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a new <a class="el" href="classseal_1_1IntArray.html">IntArray</a> by copying a given one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">copy</td><td>The <a class="el" href="classseal_1_1IntArray.html">IntArray</a> to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d7b42e48e2123a6a4ed9bf3f675eb65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d7b42e48e2123a6a4ed9bf3f675eb65">&#9670;&nbsp;</a></span>IntArray() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_, typename  = std::enable_if_t&lt;std::is_integral&lt;T_&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1IntArray.html">seal::IntArray</a>&lt; T_, typename &gt;::<a class="el" href="classseal_1_1IntArray.html">IntArray</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1IntArray.html">IntArray</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a new <a class="el" href="classseal_1_1IntArray.html">IntArray</a> by moving a given one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>The <a class="el" href="classseal_1_1IntArray.html">IntArray</a> to move from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a25f7ad01501e51d63773b58ea9a8484e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f7ad01501e51d63773b58ea9a8484e">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_, typename  = std::enable_if_t&lt;std::is_integral&lt;T_&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD const T&amp; <a class="el" href="classseal_1_1IntArray.html">seal::IntArray</a>&lt; T_, typename &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a constant reference to the array element at a given index. This function performs bounds checking and will throw an error if the index is out of range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the array element </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index is out of range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4dc307d4afcadf885f55dd15b034016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4dc307d4afcadf885f55dd15b034016">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_, typename  = std::enable_if_t&lt;std::is_integral&lt;T_&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD T&amp; <a class="el" href="classseal_1_1IntArray.html">seal::IntArray</a>&lt; T_, typename &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the array element at a given index. This function performs bounds checking and will throw an error if the index is out of range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the array element </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index is out of range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8de7d43ee9c352feced82070341c308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8de7d43ee9c352feced82070341c308">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_, typename  = std::enable_if_t&lt;std::is_integral&lt;T_&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD T* <a class="el" href="classseal_1_1IntArray.html">seal::IntArray</a>&lt; T_, typename &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer to the beginning of the array data. </p>

</div>
</div>
<a id="a193ec07b466a83467217b81a90f6063d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193ec07b466a83467217b81a90f6063d">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_, typename  = std::enable_if_t&lt;std::is_integral&lt;T_&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD size_type <a class="el" href="classseal_1_1IntArray.html">seal::IntArray</a>&lt; T_, typename &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the capacity of the array. </p>

</div>
</div>
<a id="ad97c5a47b22021a4f756199af68c8ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad97c5a47b22021a4f756199af68c8ef4">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_, typename  = std::enable_if_t&lt;std::is_integral&lt;T_&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD const T* <a class="el" href="classseal_1_1IntArray.html">seal::IntArray</a>&lt; T_, typename &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a constant pointer to the beginning of the array data. </p>

</div>
</div>
<a id="aab4ca5dd85b405c9158cb20d4251d9d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab4ca5dd85b405c9158cb20d4251d9d8">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_, typename  = std::enable_if_t&lt;std::is_integral&lt;T_&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD const T* <a class="el" href="classseal_1_1IntArray.html">seal::IntArray</a>&lt; T_, typename &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a constant pointer to the end of the array data. </p>

</div>
</div>
<a id="a6f60521bd10e519d780618efa4dc6c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f60521bd10e519d780618efa4dc6c64">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_, typename  = std::enable_if_t&lt;std::is_integral&lt;T_&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseal_1_1IntArray.html">seal::IntArray</a>&lt; T_, typename &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the size of the array to zero. The capacity is not changed. </p>

</div>
</div>
<a id="acaf0ba60b8223cf67e1e104a49638302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf0ba60b8223cf67e1e104a49638302">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_, typename  = std::enable_if_t&lt;std::is_integral&lt;T_&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD bool <a class="el" href="classseal_1_1IntArray.html">seal::IntArray</a>&lt; T_, typename &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the array has size zero. </p>

</div>
</div>
<a id="af61ab57a81878714bc9e56abb5d72a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61ab57a81878714bc9e56abb5d72a36">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_, typename  = std::enable_if_t&lt;std::is_integral&lt;T_&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD T* <a class="el" href="classseal_1_1IntArray.html">seal::IntArray</a>&lt; T_, typename &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer to the end of the array data. </p>

</div>
</div>
<a id="afe50b857a18abaa06f48233b6eb20529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe50b857a18abaa06f48233b6eb20529">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_, typename  = std::enable_if_t&lt;std::is_integral&lt;T_&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseal_1_1IntArray.html">seal::IntArray</a>&lt; T_, typename &gt;::load </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads a <a class="el" href="classseal_1_1IntArray.html">IntArray</a> from an input stream overwriting the current <a class="el" href="classseal_1_1IntArray.html">IntArray</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>The stream to load the <a class="el" href="classseal_1_1IntArray.html">IntArray</a> from </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if a valid <a class="el" href="classseal_1_1IntArray.html">IntArray</a> could not be read from stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af310bf3e59e36430691804b8da56e2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af310bf3e59e36430691804b8da56e2df">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_, typename  = std::enable_if_t&lt;std::is_integral&lt;T_&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD size_type <a class="el" href="classseal_1_1IntArray.html">seal::IntArray</a>&lt; T_, typename &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the largest possible array size. </p>

</div>
</div>
<a id="acec296ea7f1acde1de8517655786504c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec296ea7f1acde1de8517655786504c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_, typename  = std::enable_if_t&lt;std::is_integral&lt;T_&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1IntArray.html">IntArray</a>&lt;T&gt;&amp; <a class="el" href="classseal_1_1IntArray.html">seal::IntArray</a>&lt; T_, typename &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1IntArray.html">IntArray</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>assign</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies a given <a class="el" href="classseal_1_1IntArray.html">IntArray</a> to the current one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">assign</td><td>The <a class="el" href="classseal_1_1IntArray.html">IntArray</a> to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55430c508fffeb110e565b26685f24dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55430c508fffeb110e565b26685f24dc">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_, typename  = std::enable_if_t&lt;std::is_integral&lt;T_&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1IntArray.html">IntArray</a>&lt;T&gt;&amp; <a class="el" href="classseal_1_1IntArray.html">seal::IntArray</a>&lt; T_, typename &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1IntArray.html">IntArray</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>assign</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Moves a given <a class="el" href="classseal_1_1IntArray.html">IntArray</a> to the current one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">assign</td><td>The <a class="el" href="classseal_1_1IntArray.html">IntArray</a> to move from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38ef84191dd7df624ed7d1cde180ac0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ef84191dd7df624ed7d1cde180ac0d">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_, typename  = std::enable_if_t&lt;std::is_integral&lt;T_&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD const T&amp; <a class="el" href="classseal_1_1IntArray.html">seal::IntArray</a>&lt; T_, typename &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a constant reference to the array element at a given index. This function does not perform bounds checking.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the array element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83342d295637419fff4e9958ca451bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83342d295637419fff4e9958ca451bab">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_, typename  = std::enable_if_t&lt;std::is_integral&lt;T_&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD T&amp; <a class="el" href="classseal_1_1IntArray.html">seal::IntArray</a>&lt; T_, typename &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the array element at a given index. This function does not perform bounds checking.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the array element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adac37d01c2640d99d8ee367cb6c5c275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac37d01c2640d99d8ee367cb6c5c275">&#9670;&nbsp;</a></span>pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_, typename  = std::enable_if_t&lt;std::is_integral&lt;T_&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a> <a class="el" href="classseal_1_1IntArray.html">seal::IntArray</a>&lt; T_, typename &gt;::pool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the currently used <a class="el" href="classseal_1_1MemoryPoolHandle.html">MemoryPoolHandle</a>. </p>

</div>
</div>
<a id="aca1b6e1cc7376e5c575bd851482246a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca1b6e1cc7376e5c575bd851482246a2">&#9670;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_, typename  = std::enable_if_t&lt;std::is_integral&lt;T_&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseal_1_1IntArray.html">seal::IntArray</a>&lt; T_, typename &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Releases any allocated memory to the memory pool and sets the size and capacity of the array to zero. </p>

</div>
</div>
<a id="a7fe80f93120745b91b54cfd6993ba7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fe80f93120745b91b54cfd6993ba7c9">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_, typename  = std::enable_if_t&lt;std::is_integral&lt;T_&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseal_1_1IntArray.html">seal::IntArray</a>&lt; T_, typename &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates enough memory for storing a given number of elements without changing the size of the array. If the given capacity is smaller than the current size, the size is automatically set to equal the new capacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>The capacity of the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af061f0022f82e59dec54ec3c0fe83d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af061f0022f82e59dec54ec3c0fe83d6e">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_, typename  = std::enable_if_t&lt;std::is_integral&lt;T_&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseal_1_1IntArray.html">seal::IntArray</a>&lt; T_, typename &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes the array to given size. When resizing to larger size the data in the array remains unchanged and any new space is initialized to zero; when resizing to smaller size the last elements of the array are dropped. If the capacity is not already large enough to hold the new size, the array is also reallocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0551280bc8ce0342b6cd299c7aed97f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0551280bc8ce0342b6cd299c7aed97f5">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_, typename  = std::enable_if_t&lt;std::is_integral&lt;T_&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseal_1_1IntArray.html">seal::IntArray</a>&lt; T_, typename &gt;::save </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Saves the <a class="el" href="classseal_1_1IntArray.html">IntArray</a> to an output stream. The output is in binary format and not human-readable. The output stream must have the "binary" flag set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>The stream to save the <a class="el" href="classseal_1_1IntArray.html">IntArray</a> to </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <a class="el" href="classseal_1_1IntArray.html">IntArray</a> could not be written to stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85a78b37d04ace09bb22dbe1d2340c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a78b37d04ace09bb22dbe1d2340c41">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_, typename  = std::enable_if_t&lt;std::is_integral&lt;T_&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseal_1_1IntArray.html">seal::IntArray</a>&lt; T_, typename &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reallocates the array so that its capacity exactly matches its size. </p>

</div>
</div>
<a id="a7555aca03cbd60d3911dc641228949eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7555aca03cbd60d3911dc641228949eb">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_, typename  = std::enable_if_t&lt;std::is_integral&lt;T_&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD size_type <a class="el" href="classseal_1_1IntArray.html">seal::IntArray</a>&lt; T_, typename &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the size of the array. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>seal/<a class="el" href="intarray_8h_source.html">intarray.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
