<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEAL: seal::BigUInt Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SEAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>seal</b></li><li class="navelem"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classseal_1_1BigUInt-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">seal::BigUInt Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="biguint_8h_source.html">biguint.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a85d0e138f370613febf1eae4088b7442"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a85d0e138f370613febf1eae4088b7442">BigUInt</a> ()=default</td></tr>
<tr class="separator:a85d0e138f370613febf1eae4088b7442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b42f635e3b314e31077faf1ee3ad89"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#ab0b42f635e3b314e31077faf1ee3ad89">BigUInt</a> (int <a class="el" href="classseal_1_1BigUInt.html#af4e1cb24585633802a1012cdac2e8fd4">bit_count</a>)</td></tr>
<tr class="separator:ab0b42f635e3b314e31077faf1ee3ad89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae77a8e517f75a227079158a50336ad7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#aae77a8e517f75a227079158a50336ad7">BigUInt</a> (const std::string &amp;hex_value)</td></tr>
<tr class="separator:aae77a8e517f75a227079158a50336ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4246d91848630502594a7ec4d92ee67d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a4246d91848630502594a7ec4d92ee67d">BigUInt</a> (int <a class="el" href="classseal_1_1BigUInt.html#af4e1cb24585633802a1012cdac2e8fd4">bit_count</a>, const std::string &amp;hex_value)</td></tr>
<tr class="separator:a4246d91848630502594a7ec4d92ee67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca2a509a75eb85ae6f2743551ecf1e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a2ca2a509a75eb85ae6f2743551ecf1e9">BigUInt</a> (int <a class="el" href="classseal_1_1BigUInt.html#af4e1cb24585633802a1012cdac2e8fd4">bit_count</a>, std::uint64_t *value)</td></tr>
<tr class="separator:a2ca2a509a75eb85ae6f2743551ecf1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd148359affe48b0a41f678a06106b8d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#afd148359affe48b0a41f678a06106b8d">BigUInt</a> (int <a class="el" href="classseal_1_1BigUInt.html#af4e1cb24585633802a1012cdac2e8fd4">bit_count</a>, std::uint64_t value)</td></tr>
<tr class="separator:afd148359affe48b0a41f678a06106b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d9b14b039cd81c1f11ee0242df99eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#ac4d9b14b039cd81c1f11ee0242df99eb">BigUInt</a> (const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;copy)</td></tr>
<tr class="separator:ac4d9b14b039cd81c1f11ee0242df99eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301c2ecab45f3ec3c36cfa63dfdd0b77"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a301c2ecab45f3ec3c36cfa63dfdd0b77">BigUInt</a> (<a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&amp;source) noexcept</td></tr>
<tr class="separator:a301c2ecab45f3ec3c36cfa63dfdd0b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af51103b3fdb662a20435c50df6bcc5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a1af51103b3fdb662a20435c50df6bcc5">~BigUInt</a> () noexcept</td></tr>
<tr class="separator:a1af51103b3fdb662a20435c50df6bcc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbee1c218fb819698a7f60f1cc372b47"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#adbee1c218fb819698a7f60f1cc372b47">is_alias</a> () const noexcept</td></tr>
<tr class="separator:adbee1c218fb819698a7f60f1cc372b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e1cb24585633802a1012cdac2e8fd4"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#af4e1cb24585633802a1012cdac2e8fd4">bit_count</a> () const noexcept</td></tr>
<tr class="separator:af4e1cb24585633802a1012cdac2e8fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7199556004ef736b7f73481dd502ae0"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD std::uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#ad7199556004ef736b7f73481dd502ae0">data</a> ()</td></tr>
<tr class="separator:ad7199556004ef736b7f73481dd502ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b058b5246e070595d7338f7a06f3db"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD const std::uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#af7b058b5246e070595d7338f7a06f3db">data</a> () const noexcept</td></tr>
<tr class="separator:af7b058b5246e070595d7338f7a06f3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a6a29512b8f16b34e9f96d7b6321f8"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#ac4a6a29512b8f16b34e9f96d7b6321f8">byte_count</a> () const</td></tr>
<tr class="separator:ac4a6a29512b8f16b34e9f96d7b6321f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab774fd3eba01b2a38a6c9c286a5ec2bd"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#ab774fd3eba01b2a38a6c9c286a5ec2bd">uint64_count</a> () const</td></tr>
<tr class="separator:ab774fd3eba01b2a38a6c9c286a5ec2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126852601318c9d0c297d2f0df1c2602"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a126852601318c9d0c297d2f0df1c2602">significant_bit_count</a> () const</td></tr>
<tr class="separator:a126852601318c9d0c297d2f0df1c2602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61484c57a3dad961f18d3f10beb6b5e7"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a61484c57a3dad961f18d3f10beb6b5e7">to_double</a> () const noexcept</td></tr>
<tr class="separator:a61484c57a3dad961f18d3f10beb6b5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8bfae85308e6e5d848931f63f00549b"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#ab8bfae85308e6e5d848931f63f00549b">to_string</a> () const</td></tr>
<tr class="separator:ab8bfae85308e6e5d848931f63f00549b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6faf4945324c685c56beb8082755c13"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#af6faf4945324c685c56beb8082755c13">to_dec_string</a> () const</td></tr>
<tr class="separator:af6faf4945324c685c56beb8082755c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56bc2474838e15dca75ec19f08eb232"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#ac56bc2474838e15dca75ec19f08eb232">is_zero</a> () const</td></tr>
<tr class="separator:ac56bc2474838e15dca75ec19f08eb232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36205abc360727c4ea95a41026cfa42"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD const SEAL_BYTE &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#af36205abc360727c4ea95a41026cfa42">operator[]</a> (std::size_t index) const</td></tr>
<tr class="separator:af36205abc360727c4ea95a41026cfa42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf82364afb4e1007d1f0e10c7d3db3e8"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD SEAL_BYTE &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#acf82364afb4e1007d1f0e10c7d3db3e8">operator[]</a> (std::size_t index)</td></tr>
<tr class="separator:acf82364afb4e1007d1f0e10c7d3db3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6874bba3dd7e0ad370c6b395aa3718d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#ac6874bba3dd7e0ad370c6b395aa3718d">set_zero</a> ()</td></tr>
<tr class="separator:ac6874bba3dd7e0ad370c6b395aa3718d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fdddc058b0d3f06bee211503e8b6a0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a2fdddc058b0d3f06bee211503e8b6a0c">resize</a> (int <a class="el" href="classseal_1_1BigUInt.html#af4e1cb24585633802a1012cdac2e8fd4">bit_count</a>)</td></tr>
<tr class="separator:a2fdddc058b0d3f06bee211503e8b6a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4690d249a43d857c32a9a79204326b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#aa4690d249a43d857c32a9a79204326b7">alias</a> (int <a class="el" href="classseal_1_1BigUInt.html#af4e1cb24585633802a1012cdac2e8fd4">bit_count</a>, std::uint64_t *value)</td></tr>
<tr class="separator:aa4690d249a43d857c32a9a79204326b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbc0f6b30a08016ea3c55ec23377c33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a8fbc0f6b30a08016ea3c55ec23377c33">unalias</a> ()</td></tr>
<tr class="separator:a8fbc0f6b30a08016ea3c55ec23377c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824a227872cba0040bcd37deea67e408"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a824a227872cba0040bcd37deea67e408">operator=</a> (const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;assign)</td></tr>
<tr class="separator:a824a227872cba0040bcd37deea67e408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf3000f54ab0abb09a3791a56e2d27a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a1cf3000f54ab0abb09a3791a56e2d27a">operator=</a> (const std::string &amp;hex_value)</td></tr>
<tr class="separator:a1cf3000f54ab0abb09a3791a56e2d27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf2a891bd5f62c115f63309787df186"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#accf2a891bd5f62c115f63309787df186">operator=</a> (std::uint64_t value)</td></tr>
<tr class="separator:accf2a891bd5f62c115f63309787df186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352b848841a744feee0fcc5b7f970362"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a352b848841a744feee0fcc5b7f970362">operator+</a> () const</td></tr>
<tr class="separator:a352b848841a744feee0fcc5b7f970362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ec4532f0bc9091179e46e5ad79ecd4"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#ac7ec4532f0bc9091179e46e5ad79ecd4">operator-</a> () const</td></tr>
<tr class="separator:ac7ec4532f0bc9091179e46e5ad79ecd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef7243721c19bec8d2c2d0b08883696"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a6ef7243721c19bec8d2c2d0b08883696">operator~</a> () const</td></tr>
<tr class="separator:a6ef7243721c19bec8d2c2d0b08883696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ce0626e3217b47327a1036743bd676"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#ae3ce0626e3217b47327a1036743bd676">operator++</a> ()</td></tr>
<tr class="separator:ae3ce0626e3217b47327a1036743bd676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eeec35e9c118922371fb7f397208821"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a6eeec35e9c118922371fb7f397208821">operator--</a> ()</td></tr>
<tr class="separator:a6eeec35e9c118922371fb7f397208821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31d07e6657b75bcaa94c6c9ba3374c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#af31d07e6657b75bcaa94c6c9ba3374c4">operator++</a> (int postfix SEAL_MAYBE_UNUSED)</td></tr>
<tr class="separator:af31d07e6657b75bcaa94c6c9ba3374c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4255916fde705f995e8dcb38dea60680"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a4255916fde705f995e8dcb38dea60680">operator--</a> (int postfix SEAL_MAYBE_UNUSED)</td></tr>
<tr class="separator:a4255916fde705f995e8dcb38dea60680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44aca14183e4ceceb3fe20ccc430d9de"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a44aca14183e4ceceb3fe20ccc430d9de">operator+</a> (const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;operand2) const</td></tr>
<tr class="separator:a44aca14183e4ceceb3fe20ccc430d9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f03e3b121ff90ed2d7c5828c9b6ef9e"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a0f03e3b121ff90ed2d7c5828c9b6ef9e">operator+</a> (std::uint64_t operand2) const</td></tr>
<tr class="separator:a0f03e3b121ff90ed2d7c5828c9b6ef9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9940b77c0469db30b30db38067201195"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a9940b77c0469db30b30db38067201195">operator-</a> (const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;operand2) const</td></tr>
<tr class="separator:a9940b77c0469db30b30db38067201195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfe5e3f1f1c279e6713b72f20701116"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a9dfe5e3f1f1c279e6713b72f20701116">operator-</a> (std::uint64_t operand2) const</td></tr>
<tr class="separator:a9dfe5e3f1f1c279e6713b72f20701116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff42e142b0937790ad290b0ac667713"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a2ff42e142b0937790ad290b0ac667713">operator*</a> (const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;operand2) const</td></tr>
<tr class="separator:a2ff42e142b0937790ad290b0ac667713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a10e78a76f403a7c7fc80390e88bd2"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a26a10e78a76f403a7c7fc80390e88bd2">operator*</a> (std::uint64_t operand2) const</td></tr>
<tr class="separator:a26a10e78a76f403a7c7fc80390e88bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa605cdc42de626b9bc7f6da8507ea9"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a1aa605cdc42de626b9bc7f6da8507ea9">operator/</a> (const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;operand2) const</td></tr>
<tr class="separator:a1aa605cdc42de626b9bc7f6da8507ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec3152e00071759fba55e8f0eef5983"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a5ec3152e00071759fba55e8f0eef5983">operator/</a> (std::uint64_t operand2) const</td></tr>
<tr class="separator:a5ec3152e00071759fba55e8f0eef5983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae8bb9178f4a92ce2ef7548c6e15735"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a7ae8bb9178f4a92ce2ef7548c6e15735">operator^</a> (const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;operand2) const</td></tr>
<tr class="separator:a7ae8bb9178f4a92ce2ef7548c6e15735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65108bf1b0badaf4196e9a894088a3d"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#af65108bf1b0badaf4196e9a894088a3d">operator^</a> (std::uint64_t operand2) const</td></tr>
<tr class="separator:af65108bf1b0badaf4196e9a894088a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1409f943d76e2e6831fba2eed13f4a43"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a1409f943d76e2e6831fba2eed13f4a43">operator&amp;</a> (const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;operand2) const</td></tr>
<tr class="separator:a1409f943d76e2e6831fba2eed13f4a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4795803abb9798d42fb9868804a47463"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a4795803abb9798d42fb9868804a47463">operator&amp;</a> (std::uint64_t operand2) const</td></tr>
<tr class="separator:a4795803abb9798d42fb9868804a47463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e74c74c3a3857a260453d6f647c1bd2"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a7e74c74c3a3857a260453d6f647c1bd2">operator|</a> (const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;operand2) const</td></tr>
<tr class="separator:a7e74c74c3a3857a260453d6f647c1bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b7f1ae06ce213bce869bab8d90dc75"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#af1b7f1ae06ce213bce869bab8d90dc75">operator|</a> (std::uint64_t operand2) const</td></tr>
<tr class="separator:af1b7f1ae06ce213bce869bab8d90dc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee531e44b6409bc275f6d1d2402ea6cc"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#aee531e44b6409bc275f6d1d2402ea6cc">compareto</a> (const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;compare) const</td></tr>
<tr class="separator:aee531e44b6409bc275f6d1d2402ea6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9652d8f11244603d28851d470477a006"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a9652d8f11244603d28851d470477a006">compareto</a> (std::uint64_t compare) const</td></tr>
<tr class="separator:a9652d8f11244603d28851d470477a006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51ae1dc84a0c51a28f01c1d23767110"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#aa51ae1dc84a0c51a28f01c1d23767110">operator&lt;</a> (const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;compare) const</td></tr>
<tr class="separator:aa51ae1dc84a0c51a28f01c1d23767110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6020888be7ceb53d8ab5b1c79aa037d9"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a6020888be7ceb53d8ab5b1c79aa037d9">operator&lt;</a> (std::uint64_t compare) const</td></tr>
<tr class="separator:a6020888be7ceb53d8ab5b1c79aa037d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22abff1a69601aca05af088757e27f63"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a22abff1a69601aca05af088757e27f63">operator&gt;</a> (const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;compare) const</td></tr>
<tr class="separator:a22abff1a69601aca05af088757e27f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5902ab409d016828771db3776136275"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#aa5902ab409d016828771db3776136275">operator&gt;</a> (std::uint64_t compare) const</td></tr>
<tr class="separator:aa5902ab409d016828771db3776136275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85165fb347aaa325a61bd3dd852ca137"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a85165fb347aaa325a61bd3dd852ca137">operator&lt;=</a> (const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;compare) const</td></tr>
<tr class="separator:a85165fb347aaa325a61bd3dd852ca137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b7730f52e21eadb7f8994fbda543bf"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a92b7730f52e21eadb7f8994fbda543bf">operator&lt;=</a> (std::uint64_t compare) const</td></tr>
<tr class="separator:a92b7730f52e21eadb7f8994fbda543bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa304a1920515c52e393ba8775e3eae32"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#aa304a1920515c52e393ba8775e3eae32">operator&gt;=</a> (const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;compare) const</td></tr>
<tr class="separator:aa304a1920515c52e393ba8775e3eae32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7a1f5a9da90774134a4c94fc5c7de5"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#aef7a1f5a9da90774134a4c94fc5c7de5">operator&gt;=</a> (std::uint64_t compare) const</td></tr>
<tr class="separator:aef7a1f5a9da90774134a4c94fc5c7de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f0be314ac0979232efdf8f386727d5"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a89f0be314ac0979232efdf8f386727d5">operator==</a> (const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;compare) const</td></tr>
<tr class="separator:a89f0be314ac0979232efdf8f386727d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420f3d3bba5f405b802c0bf8f9ef2958"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a420f3d3bba5f405b802c0bf8f9ef2958">operator==</a> (std::uint64_t compare) const</td></tr>
<tr class="separator:a420f3d3bba5f405b802c0bf8f9ef2958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480e2d47b062b8d2f65b420c4c7a5223"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a480e2d47b062b8d2f65b420c4c7a5223">operator!=</a> (const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;compare) const</td></tr>
<tr class="separator:a480e2d47b062b8d2f65b420c4c7a5223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c10d1f1973fe915bc6685015691c924"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a8c10d1f1973fe915bc6685015691c924">operator!=</a> (std::uint64_t compare) const</td></tr>
<tr class="separator:a8c10d1f1973fe915bc6685015691c924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26cdc72c765a9f519417c7ff0af4e8bb"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a26cdc72c765a9f519417c7ff0af4e8bb">operator&lt;&lt;</a> (int shift) const</td></tr>
<tr class="separator:a26cdc72c765a9f519417c7ff0af4e8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20189b50e6671a5c593d5db3c45f1818"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a20189b50e6671a5c593d5db3c45f1818">operator&gt;&gt;</a> (int shift) const</td></tr>
<tr class="separator:a20189b50e6671a5c593d5db3c45f1818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f47aef79dd205dafb8c24fdc4a2f6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#ab9f47aef79dd205dafb8c24fdc4a2f6a">operator+=</a> (const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;operand2)</td></tr>
<tr class="separator:ab9f47aef79dd205dafb8c24fdc4a2f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a0d14291df7488be7c2e771d99d1bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#ab8a0d14291df7488be7c2e771d99d1bb">operator+=</a> (std::uint64_t operand2)</td></tr>
<tr class="separator:ab8a0d14291df7488be7c2e771d99d1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add845f7b13f7b337861cdab9c2509512"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#add845f7b13f7b337861cdab9c2509512">operator-=</a> (const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;operand2)</td></tr>
<tr class="separator:add845f7b13f7b337861cdab9c2509512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac996a1382971deefa5bbc5a36a0686c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#ac996a1382971deefa5bbc5a36a0686c5">operator-=</a> (std::uint64_t operand2)</td></tr>
<tr class="separator:ac996a1382971deefa5bbc5a36a0686c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7923124791dc620b683bdb4c59d16fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#af7923124791dc620b683bdb4c59d16fd">operator*=</a> (const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;operand2)</td></tr>
<tr class="separator:af7923124791dc620b683bdb4c59d16fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85ca7a792ff3600ece44cd24f5adf3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#ae85ca7a792ff3600ece44cd24f5adf3c">operator*=</a> (std::uint64_t operand2)</td></tr>
<tr class="separator:ae85ca7a792ff3600ece44cd24f5adf3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f33228b28b125085dbb124a8cd44c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a80f33228b28b125085dbb124a8cd44c3">operator/=</a> (const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;operand2)</td></tr>
<tr class="separator:a80f33228b28b125085dbb124a8cd44c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51f603c4015d87231d2ffdf439dfbe6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#ac51f603c4015d87231d2ffdf439dfbe6">operator/=</a> (std::uint64_t operand2)</td></tr>
<tr class="separator:ac51f603c4015d87231d2ffdf439dfbe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3580d8dadd22da795f36d6d758bba84f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a3580d8dadd22da795f36d6d758bba84f">operator^=</a> (const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;operand2)</td></tr>
<tr class="separator:a3580d8dadd22da795f36d6d758bba84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8464a06c8648b32b398490ad1e3d88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a2c8464a06c8648b32b398490ad1e3d88">operator^=</a> (std::uint64_t operand2)</td></tr>
<tr class="separator:a2c8464a06c8648b32b398490ad1e3d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac73fb24052d41c0882e344cfe5b35f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#aac73fb24052d41c0882e344cfe5b35f0">operator&amp;=</a> (const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;operand2)</td></tr>
<tr class="separator:aac73fb24052d41c0882e344cfe5b35f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84d6fee7e8056eec4785ed55eb1ff51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#af84d6fee7e8056eec4785ed55eb1ff51">operator&amp;=</a> (std::uint64_t operand2)</td></tr>
<tr class="separator:af84d6fee7e8056eec4785ed55eb1ff51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad517437173abc8811551acaba03be2df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#ad517437173abc8811551acaba03be2df">operator|=</a> (const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;operand2)</td></tr>
<tr class="separator:ad517437173abc8811551acaba03be2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb353094fc542692bd45dd7238ebb2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a5bb353094fc542692bd45dd7238ebb2b">operator|=</a> (std::uint64_t operand2)</td></tr>
<tr class="separator:a5bb353094fc542692bd45dd7238ebb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b474ba4dc73c812a0eb0b4e43cc5204"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a4b474ba4dc73c812a0eb0b4e43cc5204">operator&lt;&lt;=</a> (int shift)</td></tr>
<tr class="separator:a4b474ba4dc73c812a0eb0b4e43cc5204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461e68294b6e503fa8a212afd7d9107e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a461e68294b6e503fa8a212afd7d9107e">operator&gt;&gt;=</a> (int shift)</td></tr>
<tr class="separator:a461e68294b6e503fa8a212afd7d9107e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109dd93e893d16d25706c301f1a31e50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a109dd93e893d16d25706c301f1a31e50">divrem</a> (const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;operand2, <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;remainder) const</td></tr>
<tr class="separator:a109dd93e893d16d25706c301f1a31e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cb49d844d35b6d92a6aa650b33504e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a70cb49d844d35b6d92a6aa650b33504e">divrem</a> (std::uint64_t operand2, <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;remainder) const</td></tr>
<tr class="separator:a70cb49d844d35b6d92a6aa650b33504e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245f0c44d9fe0711e0b816b2fd6838ee"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a245f0c44d9fe0711e0b816b2fd6838ee">modinv</a> (const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;modulus) const</td></tr>
<tr class="separator:a245f0c44d9fe0711e0b816b2fd6838ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ccb83cc0f24dcd8531ff70861adf5e"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#ae3ccb83cc0f24dcd8531ff70861adf5e">modinv</a> (std::uint64_t modulus) const</td></tr>
<tr class="separator:ae3ccb83cc0f24dcd8531ff70861adf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a51d9a7112991db67dccdbd342e4929"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a4a51d9a7112991db67dccdbd342e4929">trymodinv</a> (const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;modulus, <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;inverse) const</td></tr>
<tr class="separator:a4a51d9a7112991db67dccdbd342e4929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e299df709c1fa18beea7d8b81e798f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a38e299df709c1fa18beea7d8b81e798f">trymodinv</a> (std::uint64_t modulus, <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;inverse) const</td></tr>
<tr class="separator:a38e299df709c1fa18beea7d8b81e798f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a65673c677ed098f36665f1b9df962f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a8a65673c677ed098f36665f1b9df962f">save</a> (std::ostream &amp;stream) const</td></tr>
<tr class="separator:a8a65673c677ed098f36665f1b9df962f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af375ab194ed686871381b752999d2ce5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#af375ab194ed686871381b752999d2ce5">load</a> (std::istream &amp;stream)</td></tr>
<tr class="separator:af375ab194ed686871381b752999d2ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64efdef493811849ecc7ac7755a9091e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a64efdef493811849ecc7ac7755a9091e">duplicate_to</a> (<a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;destination) const</td></tr>
<tr class="separator:a64efdef493811849ecc7ac7755a9091e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405965cba8bd1345536beb877130761e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#a405965cba8bd1345536beb877130761e">duplicate_from</a> (const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;value)</td></tr>
<tr class="separator:a405965cba8bd1345536beb877130761e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abfc001758aba95b19e6fef361074ec7b"><td class="memItemLeft" align="right" valign="top">static SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1BigUInt.html#abfc001758aba95b19e6fef361074ec7b">of</a> (std::uint64_t value)</td></tr>
<tr class="separator:abfc001758aba95b19e6fef361074ec7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents an unsigned integer with a specified bit width. Non-const BigUInts are mutable and able to be resized. The bit count for a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> (which can be read with <a class="el" href="classseal_1_1BigUInt.html#af4e1cb24585633802a1012cdac2e8fd4">bit_count()</a>) is set initially by the constructor and can be resized either explicitly with the <a class="el" href="classseal_1_1BigUInt.html#a2fdddc058b0d3f06bee211503e8b6a0c">resize()</a> function or implicitly with an assignment operation (e.g., <a class="el" href="classseal_1_1BigUInt.html#a824a227872cba0040bcd37deea67e408">operator=()</a>, <a class="el" href="classseal_1_1BigUInt.html#ab9f47aef79dd205dafb8c24fdc4a2f6a">operator+=()</a>, etc.). A rich set of unsigned integer operations are provided by the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> class, including comparison, traditional arithmetic (addition, subtraction, multiplication, division), and modular arithmetic functions.</p>
<dl class="section user"><dt>Backing Array</dt><dd>The backing array for a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> stores its unsigned integer value as a contiguous std::uint64_t array. Each std::uint64_t in the array sequentially represents 64-bits of the integer value, with the least significant quad-word storing the lower 64-bits and the order of the bits for each quad word dependent on the architecture's std::uint64_t representation. The size of the array equals the bit count of the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> (which can be read with <a class="el" href="classseal_1_1BigUInt.html#af4e1cb24585633802a1012cdac2e8fd4">bit_count()</a>) rounded up to the next std::uint64_t boundary (i.e., rounded up to the next 64-bit boundary). The <a class="el" href="classseal_1_1BigUInt.html#ab774fd3eba01b2a38a6c9c286a5ec2bd">uint64_count()</a> function returns the number of std::uint64_t in the backing array. The <a class="el" href="classseal_1_1BigUInt.html#ad7199556004ef736b7f73481dd502ae0">data()</a> function returns a pointer to the first std::uint64_t in the array. Additionally, the operator [] function allows accessing the individual bytes of the integer value in a platform-independent way - for example, reading the third byte will always return bits 16-24 of the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> value regardless of the platform being little-endian or big-endian.</dd></dl>
<dl class="section user"><dt>Implicit Resizing</dt><dd>Both the copy constructor and <a class="el" href="classseal_1_1BigUInt.html#a824a227872cba0040bcd37deea67e408">operator=()</a> allocate more memory for the backing array when needed, i.e. when the source <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> has a larger backing array than the destination. Conversely, when the destination backing array is already large enough, the data is only copied and the unnecessary higher order bits are set to zero. When new memory has to be allocated, only the significant bits of the source <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> are taken into account. This is is important, because it avoids unnecessary zero bits to be included in the destination, which in some cases could accumulate and result in very large unnecessary allocations. However, sometimes it is necessary to preserve the original size, even if some of the leading bits are zero. For this purpose <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> contains functions duplicate_from and duplicate_to, which create an exact copy of the source <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>.</dd></dl>
<dl class="section user"><dt>Alias BigUInts</dt><dd>An aliased <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> (which can be determined with <a class="el" href="classseal_1_1BigUInt.html#adbee1c218fb819698a7f60f1cc372b47">is_alias()</a>) is a special type of <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> that does not manage its underlying std::uint64_t pointer used to store the value. An aliased <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> supports most of the same operations as a non-aliased <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>, including reading and writing the value, however an aliased <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> does not internally allocate or deallocate its backing array and, therefore, does not support resizing. Any attempt, either explicitly or implicitly, to resize the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> will result in an exception being thrown. An aliased <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> can be created with the <a class="el" href="classseal_1_1BigUInt.html#a2ca2a509a75eb85ae6f2743551ecf1e9">BigUInt(int, std::uint64_t*)</a> constructor or the <a class="el" href="classseal_1_1BigUInt.html#aa4690d249a43d857c32a9a79204326b7">alias()</a> function. Note that the pointer specified to be aliased must be deallocated externally after the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is no longer in use. Aliasing is useful in cases where it is desirable to not have each <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> manage its own memory allocation and/or to prevent unnecessary copying.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>In general, reading a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is thread-safe while mutating is not. Specifically, the backing array may be freed whenever a resize occurs, the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is destroyed, or <a class="el" href="classseal_1_1BigUInt.html#aa4690d249a43d857c32a9a79204326b7">alias()</a> is called, which would invalidate the address returned by <a class="el" href="classseal_1_1BigUInt.html#ad7199556004ef736b7f73481dd502ae0">data()</a> and the byte references returned by operator []. When it is known that a resize will not occur, concurrent reading and mutating will not inherently fail but it is possible for a read to see a partially updated value from a concurrent write. A non-aliased <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> allocates its backing array from the global (thread-safe) memory pool. Consequently, creating or resizing a large number of <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> can result in a performance loss due to thread contention. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a85d0e138f370613febf1eae4088b7442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d0e138f370613febf1eae4088b7442">&#9670;&nbsp;</a></span>BigUInt() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">seal::BigUInt::BigUInt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an empty <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> with zero bit width. No memory is allocated by this constructor. </p>

</div>
</div>
<a id="ab0b42f635e3b314e31077faf1ee3ad89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b42f635e3b314e31077faf1ee3ad89">&#9670;&nbsp;</a></span>BigUInt() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">seal::BigUInt::BigUInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bit_count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a zero-initialized <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> of the specified bit width.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bit_count</td><td>The bit width </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if bit_count is negative </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae77a8e517f75a227079158a50336ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae77a8e517f75a227079158a50336ad7">&#9670;&nbsp;</a></span>BigUInt() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">seal::BigUInt::BigUInt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>hex_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> initialized and minimally sized to fit the unsigned hexadecimal integer specified by the string. The string matches the format returned by <a class="el" href="classseal_1_1BigUInt.html#ab8bfae85308e6e5d848931f63f00549b">to_string()</a> and must consist of only the characters 0-9, A-F, or a-f, most-significant nibble first.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hex_value</td><td>The hexadecimal integer string specifying the initial value </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if hex_value does not adhere to the expected format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4246d91848630502594a7ec4d92ee67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4246d91848630502594a7ec4d92ee67d">&#9670;&nbsp;</a></span>BigUInt() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">seal::BigUInt::BigUInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bit_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>hex_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> of the specified bit width and initializes it with the unsigned hexadecimal integer specified by the string. The string must match the format returned by <a class="el" href="classseal_1_1BigUInt.html#ab8bfae85308e6e5d848931f63f00549b">to_string()</a> and must consist of only the characters 0-9, A-F, or a-f, most-significant nibble first.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bit_count</td><td>The bit width </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hex_value</td><td>The hexadecimal integer string specifying the initial value </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if bit_count is negative </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if hex_value does not adhere to the expected format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ca2a509a75eb85ae6f2743551ecf1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ca2a509a75eb85ae6f2743551ecf1e9">&#9670;&nbsp;</a></span>BigUInt() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">seal::BigUInt::BigUInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bit_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an aliased <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> with the specified bit width and backing array. An aliased <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> does not internally allocate or deallocate the backing array, and instead uses the specified backing array for all read/write operations. Note that resizing is not supported by an aliased <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> and any required deallocation of the specified backing array must occur externally after the aliased <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is no longer in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bit_count</td><td>The bit width </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The backing array to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if bit_count is negative or value is null and bit_count is positive </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd148359affe48b0a41f678a06106b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd148359affe48b0a41f678a06106b8d">&#9670;&nbsp;</a></span>BigUInt() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">seal::BigUInt::BigUInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bit_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> of the specified bit width and initializes it to the specified unsigned integer value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bit_count</td><td>The bit width </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The initial value to set the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if bit_count is negative </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4d9b14b039cd81c1f11ee0242df99eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d9b14b039cd81c1f11ee0242df99eb">&#9670;&nbsp;</a></span>BigUInt() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">seal::BigUInt::BigUInt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a deep copy of a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>. The created <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> will have the same bit count and value as the original.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">copy</td><td>The <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a301c2ecab45f3ec3c36cfa63dfdd0b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301c2ecab45f3ec3c36cfa63dfdd0b77">&#9670;&nbsp;</a></span>BigUInt() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">seal::BigUInt::BigUInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> by moving an old one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>The <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> to move from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1af51103b3fdb662a20435c50df6bcc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af51103b3fdb662a20435c50df6bcc5">&#9670;&nbsp;</a></span>~BigUInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">seal::BigUInt::~BigUInt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroys the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> and deallocates the backing array if it is not an aliased <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa4690d249a43d857c32a9a79204326b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4690d249a43d857c32a9a79204326b7">&#9670;&nbsp;</a></span>alias()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::BigUInt::alias </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bit_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Makes the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> an aliased <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> with the specified bit width and backing array. An aliased <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> does not internally allocate or deallocate the backing array, and instead uses the specified backing array for all read/write operations. Note that resizing is not supported by an aliased <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> and any required deallocation of the specified backing array must occur externally after the aliased <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is no longer in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bit_count</td><td>The bit width </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The backing array to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if bit_count is negative or value is null </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4e1cb24585633802a1012cdac2e8fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e1cb24585633802a1012cdac2e8fd4">&#9670;&nbsp;</a></span>bit_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD int seal::BigUInt::bit_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the bit count for the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classseal_1_1BigUInt.html#a126852601318c9d0c297d2f0df1c2602">significant_bit_count()</a> to instead ignore leading zero bits. </dd></dl>

</div>
</div>
<a id="ac4a6a29512b8f16b34e9f96d7b6321f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a6a29512b8f16b34e9f96d7b6321f8">&#9670;&nbsp;</a></span>byte_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD std::size_t seal::BigUInt::byte_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of bytes in the backing array used to store the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> value.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> for a detailed description <a class="el" href="classseal_1_1BigUInt.html#abfc001758aba95b19e6fef361074ec7b">of</a> the format <a class="el" href="classseal_1_1BigUInt.html#abfc001758aba95b19e6fef361074ec7b">of</a> the backing array. </dd></dl>

</div>
</div>
<a id="aee531e44b6409bc275f6d1d2402ea6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee531e44b6409bc275f6d1d2402ea6cc">&#9670;&nbsp;</a></span>compareto() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD int seal::BigUInt::compareto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares two BigUInts and returns -1, 0, or 1 if the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is less-than, equal-to, or greater-than the second operand respectively. The input operands are not modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">compare</td><td>The value to compare against </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9652d8f11244603d28851d470477a006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9652d8f11244603d28851d470477a006">&#9670;&nbsp;</a></span>compareto() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD int seal::BigUInt::compareto </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> and an unsigned integer and returns -1, 0, or 1 if the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is less-than, equal-to, or greater-than the second operand respectively. The input operands are not modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">compare</td><td>The value to compare against </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7199556004ef736b7f73481dd502ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7199556004ef736b7f73481dd502ae0">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD std::uint64_t* seal::BigUInt::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer to the backing array storing the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> value. The pointer points to the beginning of the backing array at the least-significant quad word.</p>
<dl class="section warning"><dt>Warning</dt><dd>The pointer is valid only until the backing array is freed, which occurs when the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is resized, destroyed, or the <a class="el" href="classseal_1_1BigUInt.html#aa4690d249a43d857c32a9a79204326b7">alias()</a> function is called. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classseal_1_1BigUInt.html#ab774fd3eba01b2a38a6c9c286a5ec2bd">uint64_count()</a> to determine the number <a class="el" href="classseal_1_1BigUInt.html#abfc001758aba95b19e6fef361074ec7b">of</a> std::uint64_t values in the backing array. </dd></dl>

</div>
</div>
<a id="af7b058b5246e070595d7338f7a06f3db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b058b5246e070595d7338f7a06f3db">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD const std::uint64_t* seal::BigUInt::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const pointer to the backing array storing the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> value. The pointer points to the beginning of the backing array at the least-significant quad word.</p>
<dl class="section warning"><dt>Warning</dt><dd>The pointer is valid only until the backing array is freed, which occurs when the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is resized, destroyed, or the <a class="el" href="classseal_1_1BigUInt.html#aa4690d249a43d857c32a9a79204326b7">alias()</a> function is called. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classseal_1_1BigUInt.html#ab774fd3eba01b2a38a6c9c286a5ec2bd">uint64_count()</a> to determine the number <a class="el" href="classseal_1_1BigUInt.html#abfc001758aba95b19e6fef361074ec7b">of</a> std::uint64_t values in the backing array. </dd></dl>

</div>
</div>
<a id="a109dd93e893d16d25706c301f1a31e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109dd93e893d16d25706c301f1a31e50">&#9670;&nbsp;</a></span>divrem() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> seal::BigUInt::divrem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>operand2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>remainder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divides two BigUInts and returns the quotient and sets the remainder parameter to the remainder. The bit count of the quotient is set to be the significant bit count of the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>. The remainder is resized if and only if it is smaller than the bit count of the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to divide </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">remainder</td><td>The <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> to store the remainder </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::Invalid_argument</td><td>if operand2 is zero </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the remainder is an alias and the operator attempts to enlarge the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> to fit the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70cb49d844d35b6d92a6aa650b33504e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70cb49d844d35b6d92a6aa650b33504e">&#9670;&nbsp;</a></span>divrem() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> seal::BigUInt::divrem </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>operand2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>remainder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Divides a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> and an unsigned integer and returns the quotient and sets the remainder parameter to the remainder. The bit count of the quotient is set to be the significant bit count of the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>. The remainder is resized if and only if it is smaller than the bit count of the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to divide </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">remainder</td><td>The <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> to store the remainder </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::Invalid_argument</td><td>if operand2 is zero </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the remainder is an alias which the function attempts to enlarge to fit the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a405965cba8bd1345536beb877130761e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405965cba8bd1345536beb877130761e">&#9670;&nbsp;</a></span>duplicate_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::BigUInt::duplicate_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Duplicates a given <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>. The bit count and the value of the current <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> are set to be exactly the same as in the given one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> to duplicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the current <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is an alias </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64efdef493811849ecc7ac7755a9091e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64efdef493811849ecc7ac7755a9091e">&#9670;&nbsp;</a></span>duplicate_to()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::BigUInt::duplicate_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Duplicates the current <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>. The bit count and the value of the given <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> are set to be exactly the same as in the current one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> to overwrite with the duplicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the destination <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is an alias </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbee1c218fb819698a7f60f1cc372b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbee1c218fb819698a7f60f1cc372b47">&#9670;&nbsp;</a></span>is_alias()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD bool seal::BigUInt::is_alias </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether or not the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is an alias.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> for a detailed description <a class="el" href="classseal_1_1BigUInt.html#abfc001758aba95b19e6fef361074ec7b">of</a> aliased <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>. </dd></dl>

</div>
</div>
<a id="ac56bc2474838e15dca75ec19f08eb232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac56bc2474838e15dca75ec19f08eb232">&#9670;&nbsp;</a></span>is_zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD bool seal::BigUInt::is_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether or not the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> has the value zero. </p>

</div>
</div>
<a id="af375ab194ed686871381b752999d2ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af375ab194ed686871381b752999d2ce5">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::BigUInt::load </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> from an input stream overwriting the current <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> and enlarging if needed to fit the loaded <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>The stream to load the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> from </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is an alias and the loaded <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is too large to fit with the current bit </td></tr>
    <tr><td class="paramname">std::exception</td><td>if a valid <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> could not be read from stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a245f0c44d9fe0711e0b816b2fd6838ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245f0c44d9fe0711e0b816b2fd6838ee">&#9670;&nbsp;</a></span>modinv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> seal::BigUInt::modinv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>modulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the inverse of a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> with respect to the specified modulus. The original <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is not modified. The bit count of the inverse is set to be the significant bit count of the modulus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">modulus</td><td>The modulus to calculate the inverse with respect to </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::Invalid_argument</td><td>if modulus is zero </td></tr>
    <tr><td class="paramname">std::Invalid_argument</td><td>if modulus is not greater than the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> value </td></tr>
    <tr><td class="paramname">std::Invalid_argument</td><td>if the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> value and modulus are not co-prime </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3ccb83cc0f24dcd8531ff70861adf5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ccb83cc0f24dcd8531ff70861adf5e">&#9670;&nbsp;</a></span>modinv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> seal::BigUInt::modinv </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>modulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the inverse of a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> with respect to the specified modulus. The original <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is not modified. The bit count of the inverse is set to be the significant bit count of the modulus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">modulus</td><td>The modulus to calculate the inverse with respect to </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::Invalid_argument</td><td>if modulus is zero </td></tr>
    <tr><td class="paramname">std::Invalid_argument</td><td>if modulus is not greater than the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> value </td></tr>
    <tr><td class="paramname">std::Invalid_argument</td><td>if the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> value and modulus are not co-prime </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfc001758aba95b19e6fef361074ec7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc001758aba95b19e6fef361074ec7b">&#9670;&nbsp;</a></span>of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> seal::BigUInt::of </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a minimally sized <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> initialized to the specified unsigned integer value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to initialized the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a480e2d47b062b8d2f65b420c4c7a5223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480e2d47b062b8d2f65b420c4c7a5223">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD bool seal::BigUInt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether or not a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is not equal to a second <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>. The input operands are not modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">compare</td><td>The value to compare against </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c10d1f1973fe915bc6685015691c924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c10d1f1973fe915bc6685015691c924">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD bool seal::BigUInt::operator!= </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether or not a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is not equal to an unsigned integer. The input operands are not modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The value to compare against </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1409f943d76e2e6831fba2eed13f4a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1409f943d76e2e6831fba2eed13f4a43">&#9670;&nbsp;</a></span>operator&() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> seal::BigUInt::operator &amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>operand2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a bit-wise AND operation between two BigUInts and returns the result. The input operands are not modified. The bit count of the result is set to the maximum of the two input operand bit counts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to AND </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4795803abb9798d42fb9868804a47463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4795803abb9798d42fb9868804a47463">&#9670;&nbsp;</a></span>operator&() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> seal::BigUInt::operator &amp; </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>operand2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a bit-wise AND operation between a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> and an unsigned integer and returns the result. The input operands are not modified. The bit count of the result is set to the maximum of the two input operand bit counts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to AND </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac73fb24052d41c0882e344cfe5b35f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac73fb24052d41c0882e344cfe5b35f0">&#9670;&nbsp;</a></span>operator&=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&amp; seal::BigUInt::operator &amp;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>operand2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a bit-wise AND operation between two BigUInts saving the result to the first operand, returning a reference of the first operand. The second input operand is not modified. The first operand is resized if and only if its bit count is smaller than the significant bit count of the second operand.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to AND </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is an alias and the operator attempts to enlarge the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> to fit the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af84d6fee7e8056eec4785ed55eb1ff51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84d6fee7e8056eec4785ed55eb1ff51">&#9670;&nbsp;</a></span>operator&=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&amp; seal::BigUInt::operator &amp;= </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>operand2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a bit-wise AND operation between a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> and an unsigned integer saving the result to the first operand, returning a reference of the first operand. The second input operand is not modified. The first operand is resized if and only if its bit count is smaller than the significant bit count of the second operand.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to AND </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is an alias and the operator attempts to enlarge the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> to fit the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ff42e142b0937790ad290b0ac667713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff42e142b0937790ad290b0ac667713">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> seal::BigUInt::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>operand2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies two BigUInts and returns the product. The input operands are not modified. The bit count of the product is set to be the sum of the significant bit counts of the two input operands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to multiply </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26a10e78a76f403a7c7fc80390e88bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26a10e78a76f403a7c7fc80390e88bd2">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> seal::BigUInt::operator* </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>operand2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> and an unsigned integer and returns the product. The input operands are not modified. The bit count of the product is set to be the sum of the significant bit counts of the two input operands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to multiply </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7923124791dc620b683bdb4c59d16fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7923124791dc620b683bdb4c59d16fd">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&amp; seal::BigUInt::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>operand2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies two BigUInts saving the product to the first operand, returning a reference of the first operand. The second input operand is not modified. The first operand is resized if and only if its bit count is smaller than the sum of the significant bit counts of the two input operands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to multiply </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is an alias and the operator attempts to enlarge the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> to fit the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae85ca7a792ff3600ece44cd24f5adf3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae85ca7a792ff3600ece44cd24f5adf3c">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&amp; seal::BigUInt::operator*= </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>operand2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> and an unsigned integer saving the product to the first operand, returning a reference of the first operand. The second input operand is not modified. The first operand is resized if and only if its bit count is smaller than the sum of the significant bit counts of the two input operands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to multiply </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is an alias and the operator attempts to enlarge the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> to fit the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a352b848841a744feee0fcc5b7f970362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352b848841a744feee0fcc5b7f970362">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> seal::BigUInt::operator+ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a copy of the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> value resized to the significant bit count. </p>

</div>
</div>
<a id="a44aca14183e4ceceb3fe20ccc430d9de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44aca14183e4ceceb3fe20ccc430d9de">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> seal::BigUInt::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>operand2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds two BigUInts and returns the sum. The input operands are not modified. The bit count of the sum is set to be one greater than the significant bit count of the larger of the two input operands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f03e3b121ff90ed2d7c5828c9b6ef9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f03e3b121ff90ed2d7c5828c9b6ef9e">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> seal::BigUInt::operator+ </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>operand2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> and an unsigned integer and returns the sum. The input operands are not modified. The bit count of the sum is set to be one greater than the significant bit count of the larger of the two operands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3ce0626e3217b47327a1036743bd676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ce0626e3217b47327a1036743bd676">&#9670;&nbsp;</a></span>operator++() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&amp; seal::BigUInt::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Increments the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> and returns the incremented value. The <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> will increment the bit count if needed to fit the carry.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is an alias and a carry occurs requiring the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> to be resized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af31d07e6657b75bcaa94c6c9ba3374c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31d07e6657b75bcaa94c6c9ba3374c4">&#9670;&nbsp;</a></span>operator++() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> seal::BigUInt::operator++ </td>
          <td>(</td>
          <td class="paramtype">int postfix&#160;</td>
          <td class="paramname"><em>SEAL_MAYBE_UNUSED</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Increments the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> but returns its old value. The <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> will increment the bit count if needed to fit the carry. </p>

</div>
</div>
<a id="ab9f47aef79dd205dafb8c24fdc4a2f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f47aef79dd205dafb8c24fdc4a2f6a">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&amp; seal::BigUInt::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>operand2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds two BigUInts saving the sum to the first operand, returning a reference of the first operand. The second input operand is not modified. The first operand is resized if and only if its bit count is smaller than one greater than the significant bit count of the larger of the two input operands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is an alias and the operator attempts to enlarge the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> to fit the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8a0d14291df7488be7c2e771d99d1bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a0d14291df7488be7c2e771d99d1bb">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&amp; seal::BigUInt::operator+= </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>operand2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> and an unsigned integer saving the sum to the first operand, returning a reference of the first operand. The second input operand is not modified. The first operand is resized if and only if its bit count is smaller than one greater than the significant bit count of the larger of the two input operands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is an alias and the operator attempts to enlarge the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> to fit the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7ec4532f0bc9091179e46e5ad79ecd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ec4532f0bc9091179e46e5ad79ecd4">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> seal::BigUInt::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a negated copy of the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> value. The bit count does not change. </p>

</div>
</div>
<a id="a9940b77c0469db30b30db38067201195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9940b77c0469db30b30db38067201195">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> seal::BigUInt::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>operand2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtracts two BigUInts and returns the difference. The input operands are not modified. The bit count of the difference is set to be the significant bit count of the larger of the two input operands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to subtract </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9dfe5e3f1f1c279e6713b72f20701116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dfe5e3f1f1c279e6713b72f20701116">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> seal::BigUInt::operator- </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>operand2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtracts a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> and an unsigned integer and returns the difference. The input operands are not modified. The bit count of the difference is set to be the significant bit count of the larger of the two operands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to subtract </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6eeec35e9c118922371fb7f397208821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eeec35e9c118922371fb7f397208821">&#9670;&nbsp;</a></span>operator--() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&amp; seal::BigUInt::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decrements the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> and returns the decremented value. The bit count does not change. </p>

</div>
</div>
<a id="a4255916fde705f995e8dcb38dea60680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4255916fde705f995e8dcb38dea60680">&#9670;&nbsp;</a></span>operator--() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> seal::BigUInt::operator-- </td>
          <td>(</td>
          <td class="paramtype">int postfix&#160;</td>
          <td class="paramname"><em>SEAL_MAYBE_UNUSED</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decrements the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> but returns its old value. The bit count does not change. </p>

</div>
</div>
<a id="add845f7b13f7b337861cdab9c2509512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add845f7b13f7b337861cdab9c2509512">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&amp; seal::BigUInt::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>operand2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtracts two BigUInts saving the difference to the first operand, returning a reference of the first operand. The second input operand is not modified. The first operand is resized if and only if its bit count is smaller than the significant bit count of the second operand.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to subtract </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is an alias and the operator attempts to enlarge the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> to fit the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac996a1382971deefa5bbc5a36a0686c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac996a1382971deefa5bbc5a36a0686c5">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&amp; seal::BigUInt::operator-= </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>operand2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtracts a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> and an unsigned integer saving the difference to the first operand, returning a reference of the first operand. The second input operand is not modified. The first operand is resized if and only if its bit count is smaller than the significant bit count of the second operand.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to subtract </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is an alias and the operator attempts to enlarge the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> to fit the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1aa605cdc42de626b9bc7f6da8507ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa605cdc42de626b9bc7f6da8507ea9">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> seal::BigUInt::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>operand2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divides two BigUInts and returns the quotient. The input operands are not modified. The bit count of the quotient is set to be the significant bit count of the first input operand.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to divide </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if operand2 is zero </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ec3152e00071759fba55e8f0eef5983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec3152e00071759fba55e8f0eef5983">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> seal::BigUInt::operator/ </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>operand2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Divides a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> and an unsigned integer and returns the quotient. The input operands are not modified. The bit count of the quotient is set to be the significant bit count of the first input operand.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to divide </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if operand2 is zero </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80f33228b28b125085dbb124a8cd44c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f33228b28b125085dbb124a8cd44c3">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&amp; seal::BigUInt::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>operand2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Divides two BigUInts saving the quotient to the first operand, returning a reference of the first operand. The second input operand is not modified. The first operand is never resized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to divide </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if operand2 is zero </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac51f603c4015d87231d2ffdf439dfbe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac51f603c4015d87231d2ffdf439dfbe6">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&amp; seal::BigUInt::operator/= </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>operand2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Divides a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> and an unsigned integer saving the quotient to the first operand, returning a reference of the first operand. The second input operand is not modified. The first operand is never resized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to divide </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if operand2 is zero </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa51ae1dc84a0c51a28f01c1d23767110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51ae1dc84a0c51a28f01c1d23767110">&#9670;&nbsp;</a></span>operator<() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD bool seal::BigUInt::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether or not a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is less-than a second <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>. The input operands are not modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The value to compare against </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6020888be7ceb53d8ab5b1c79aa037d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6020888be7ceb53d8ab5b1c79aa037d9">&#9670;&nbsp;</a></span>operator<() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD bool seal::BigUInt::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether or not a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is less-than an unsigned integer. The input operands are not modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The value to compare against </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26cdc72c765a9f519417c7ff0af4e8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26cdc72c765a9f519417c7ff0af4e8bb">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> seal::BigUInt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shift</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a left-shifted copy of the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>. The bit count of the returned value is the sum of the original significant bit count and the shift amount.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shift</td><td>The number of bits to shift by </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if shift is negative </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b474ba4dc73c812a0eb0b4e43cc5204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b474ba4dc73c812a0eb0b4e43cc5204">&#9670;&nbsp;</a></span>operator<<=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&amp; seal::BigUInt::operator&lt;&lt;= </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shift</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Left-shifts a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> by the specified amount. The <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is resized if and only if its bit count is smaller than the sum of its significant bit count and the shift amount.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shift</td><td>The number of bits to shift by </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::Invalid_argument</td><td>if shift is negative </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is an alias and the operator attempts to enlarge the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> to fit the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85165fb347aaa325a61bd3dd852ca137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85165fb347aaa325a61bd3dd852ca137">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD bool seal::BigUInt::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether or not a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is less-than or equal to a second <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>. The input operands are not modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The value to compare against </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92b7730f52e21eadb7f8994fbda543bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b7730f52e21eadb7f8994fbda543bf">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD bool seal::BigUInt::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether or not a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is less-than or equal to an unsigned integer. The input operands are not modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The value to compare against </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a824a227872cba0040bcd37deea67e408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824a227872cba0040bcd37deea67e408">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp; seal::BigUInt::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>assign</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overwrites the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> with the value of the specified <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>, enlarging if needed to fit the assigned value. Only significant bits are used to size the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">assign</td><td>The <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> whose value should be assigned to the current <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is an alias and the assigned <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is too large to fit the current bit width </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1cf3000f54ab0abb09a3791a56e2d27a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf3000f54ab0abb09a3791a56e2d27a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&amp; seal::BigUInt::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>hex_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overwrites the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> with the unsigned hexadecimal value specified by the string, enlarging if needed to fit the assigned value. The string must match the format returned by <a class="el" href="classseal_1_1BigUInt.html#ab8bfae85308e6e5d848931f63f00549b">to_string()</a> and must consist of only the characters 0-9, A-F, or a-f, most-significant nibble first.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hex_value</td><td>The hexadecimal integer string specifying the value to assign </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if hex_value does not adhere to the expected format </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is an alias and the assigned value is too large to fit the current bit width </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="accf2a891bd5f62c115f63309787df186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf2a891bd5f62c115f63309787df186">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&amp; seal::BigUInt::operator= </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overwrites the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> with the specified integer value, enlarging if needed to fit the value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to assign </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is an alias and the significant bit count of value is too large to fit the current bit width </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89f0be314ac0979232efdf8f386727d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f0be314ac0979232efdf8f386727d5">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD bool seal::BigUInt::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether or not a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is equal to a second <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>. The input operands are not modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">compare</td><td>The value to compare against </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a420f3d3bba5f405b802c0bf8f9ef2958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420f3d3bba5f405b802c0bf8f9ef2958">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD bool seal::BigUInt::operator== </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether or not a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is equal to an unsigned integer. The input operands are not modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">compare</td><td>The value to compare against </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22abff1a69601aca05af088757e27f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22abff1a69601aca05af088757e27f63">&#9670;&nbsp;</a></span>operator>() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD bool seal::BigUInt::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether or not a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is greater-than a second <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>. The input operands are not modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The value to compare against </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5902ab409d016828771db3776136275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5902ab409d016828771db3776136275">&#9670;&nbsp;</a></span>operator>() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD bool seal::BigUInt::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether or not a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is greater-than an unsigned integer. The input operands are not modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The value to compare against </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa304a1920515c52e393ba8775e3eae32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa304a1920515c52e393ba8775e3eae32">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD bool seal::BigUInt::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether or not a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is greater-than or equal to a second <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>. The input operands are not modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The value to compare against </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef7a1f5a9da90774134a4c94fc5c7de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef7a1f5a9da90774134a4c94fc5c7de5">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD bool seal::BigUInt::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether or not a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is greater-than or equal to an unsigned integer. The input operands are not modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The value to compare against </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20189b50e6671a5c593d5db3c45f1818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20189b50e6671a5c593d5db3c45f1818">&#9670;&nbsp;</a></span>operator>>()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> seal::BigUInt::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shift</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a right-shifted copy of the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>. The bit count of the returned value is the original significant bit count subtracted by the shift amount (clipped to zero if negative).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shift</td><td>The number of bits to shift by </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if shift is negative </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a461e68294b6e503fa8a212afd7d9107e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461e68294b6e503fa8a212afd7d9107e">&#9670;&nbsp;</a></span>operator>>=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&amp; seal::BigUInt::operator&gt;&gt;= </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shift</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Right-shifts a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> by the specified amount. The <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is never resized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shift</td><td>The number of bits to shift by </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::Invalid_argument</td><td>if shift is negative </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af36205abc360727c4ea95a41026cfa42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36205abc360727c4ea95a41026cfa42">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD const SEAL_BYTE&amp; seal::BigUInt::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the byte at the corresponding byte index of the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>'s integer value. The bytes of the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> are indexed least-significant byte first.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the byte to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index is not within [0, <a class="el" href="classseal_1_1BigUInt.html#ac4a6a29512b8f16b34e9f96d7b6321f8">byte_count()</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> for a detailed description <a class="el" href="classseal_1_1BigUInt.html#abfc001758aba95b19e6fef361074ec7b">of</a> the format <a class="el" href="classseal_1_1BigUInt.html#abfc001758aba95b19e6fef361074ec7b">of</a> the backing array. </dd></dl>

</div>
</div>
<a id="acf82364afb4e1007d1f0e10c7d3db3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf82364afb4e1007d1f0e10c7d3db3e8">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD SEAL_BYTE&amp; seal::BigUInt::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an byte reference that can read/write the byte at the corresponding byte index of the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>'s integer value. The bytes of the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> are indexed least-significant byte first.</p>
<dl class="section warning"><dt>Warning</dt><dd>The returned byte is an reference backed by the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>'s backing array. As such, it is only valid until the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is resized, destroyed, or <a class="el" href="classseal_1_1BigUInt.html#aa4690d249a43d857c32a9a79204326b7">alias()</a> is called.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the byte to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index is not within [0, <a class="el" href="classseal_1_1BigUInt.html#ac4a6a29512b8f16b34e9f96d7b6321f8">byte_count()</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> for a detailed description <a class="el" href="classseal_1_1BigUInt.html#abfc001758aba95b19e6fef361074ec7b">of</a> the format <a class="el" href="classseal_1_1BigUInt.html#abfc001758aba95b19e6fef361074ec7b">of</a> the backing array. </dd></dl>

</div>
</div>
<a id="a7ae8bb9178f4a92ce2ef7548c6e15735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae8bb9178f4a92ce2ef7548c6e15735">&#9670;&nbsp;</a></span>operator^() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> seal::BigUInt::operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>operand2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a bit-wise XOR operation between two BigUInts and returns the result. The input operands are not modified. The bit count of the result is set to the maximum of the two input operand bit counts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to XOR </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af65108bf1b0badaf4196e9a894088a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af65108bf1b0badaf4196e9a894088a3d">&#9670;&nbsp;</a></span>operator^() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> seal::BigUInt::operator^ </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>operand2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a bit-wise XOR operation between a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> and an unsigned integer and returns the result. The input operands are not modified. The bit count of the result is set to the maximum of the two input operand bit counts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to XOR </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3580d8dadd22da795f36d6d758bba84f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3580d8dadd22da795f36d6d758bba84f">&#9670;&nbsp;</a></span>operator^=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&amp; seal::BigUInt::operator^= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>operand2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a bit-wise XOR operation between two BigUInts saving the result to the first operand, returning a reference of the first operand. The second input operand is not modified. The first operand is resized if and only if its bit count is smaller than the significant bit count of the second operand.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to XOR </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is an alias and the operator attempts to enlarge the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> to fit the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c8464a06c8648b32b398490ad1e3d88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8464a06c8648b32b398490ad1e3d88">&#9670;&nbsp;</a></span>operator^=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&amp; seal::BigUInt::operator^= </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>operand2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a bit-wise XOR operation between a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> and an unsigned integer saving the result to the first operand, returning a reference of the first operand. The second input operand is not modified. The first operand is resized if and only if its bit count is smaller than the significant bit count of the second operand.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to XOR </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is an alias and the operator attempts to enlarge the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> to fit the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e74c74c3a3857a260453d6f647c1bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e74c74c3a3857a260453d6f647c1bd2">&#9670;&nbsp;</a></span>operator|() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> seal::BigUInt::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>operand2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a bit-wise OR operation between two BigUInts and returns the result. The input operands are not modified. The bit count of the result is set to the maximum of the two input operand bit counts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to OR </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1b7f1ae06ce213bce869bab8d90dc75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b7f1ae06ce213bce869bab8d90dc75">&#9670;&nbsp;</a></span>operator|() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> seal::BigUInt::operator| </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>operand2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a bit-wise OR operation between a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> and an unsigned integer and returns the result. The input operands are not modified. The bit count of the result is set to the maximum of the two input operand bit counts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to OR </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad517437173abc8811551acaba03be2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad517437173abc8811551acaba03be2df">&#9670;&nbsp;</a></span>operator|=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&amp; seal::BigUInt::operator|= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>operand2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a bit-wise OR operation between two BigUInts saving the result to the first operand, returning a reference of the first operand. The second input operand is not modified. The first operand is resized if and only if its bit count is smaller than the significant bit count of the second operand.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to OR </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is an alias and the operator attempts to enlarge the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> to fit the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bb353094fc542692bd45dd7238ebb2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb353094fc542692bd45dd7238ebb2b">&#9670;&nbsp;</a></span>operator|=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>&amp; seal::BigUInt::operator|= </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>operand2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a bit-wise OR operation between a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> and an unsigned integer saving the result to the first operand, returning a reference of the first operand. The second input operand is not modified. The first operand is resized if and only if its bit count is smaller than the significant bit count of the second operand.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operand2</td><td>The second operand to OR </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is an alias and the operator attempts to enlarge the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> to fit the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ef7243721c19bec8d2c2d0b08883696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef7243721c19bec8d2c2d0b08883696">&#9670;&nbsp;</a></span>operator~()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> seal::BigUInt::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an inverted copy of the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> value. The bit count does not change. </p>

</div>
</div>
<a id="a2fdddc058b0d3f06bee211503e8b6a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fdddc058b0d3f06bee211503e8b6a0c">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::BigUInt::resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bit_count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resizes the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> to the specified bit width, copying over the old value as much as will fit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bit_count</td><td>The bit width </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if bit_count is negative </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is an alias </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a65673c677ed098f36665f1b9df962f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a65673c677ed098f36665f1b9df962f">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::BigUInt::save </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> to an output stream. The full state of the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is serialized, including insignificant bits. The output is in binary format and not human-readable. The output stream must have the "binary" flag set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>The stream to save the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> to </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> could not be written to stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6874bba3dd7e0ad370c6b395aa3718d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6874bba3dd7e0ad370c6b395aa3718d">&#9670;&nbsp;</a></span>set_zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::BigUInt::set_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> value to zero. This does not resize the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>. </p>

</div>
</div>
<a id="a126852601318c9d0c297d2f0df1c2602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a126852601318c9d0c297d2f0df1c2602">&#9670;&nbsp;</a></span>significant_bit_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD int seal::BigUInt::significant_bit_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of significant bits for the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classseal_1_1BigUInt.html#af4e1cb24585633802a1012cdac2e8fd4">bit_count()</a> to instead return the bit count regardless <a class="el" href="classseal_1_1BigUInt.html#abfc001758aba95b19e6fef361074ec7b">of</a> leading zero bits. </dd></dl>

</div>
</div>
<a id="af6faf4945324c685c56beb8082755c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6faf4945324c685c56beb8082755c13">&#9670;&nbsp;</a></span>to_dec_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string seal::BigUInt::to_dec_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> value as a decimal string. </p>

</div>
</div>
<a id="a61484c57a3dad961f18d3f10beb6b5e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61484c57a3dad961f18d3f10beb6b5e7">&#9670;&nbsp;</a></span>to_double()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD double seal::BigUInt::to_double </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> value as a double. Note that precision may be lost during the conversion. </p>

</div>
</div>
<a id="ab8bfae85308e6e5d848931f63f00549b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8bfae85308e6e5d848931f63f00549b">&#9670;&nbsp;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string seal::BigUInt::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> value as a hexadecimal string. </p>

</div>
</div>
<a id="a4a51d9a7112991db67dccdbd342e4929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a51d9a7112991db67dccdbd342e4929">&#9670;&nbsp;</a></span>trymodinv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool seal::BigUInt::trymodinv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempts to calculate the inverse of a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> with respect to the specified modulus, returning whether or not the inverse was successful and setting the inverse parameter to the inverse. The original <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is not modified. The inverse parameter is resized if and only if its bit count is smaller than the significant bit count of the modulus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">modulus</td><td>The modulus to calculate the inverse with respect to </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">inverse</td><td>Stores the inverse if the inverse operation was successful </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::Invalid_argument</td><td>if modulus is zero </td></tr>
    <tr><td class="paramname">std::Invalid_argument</td><td>if modulus is not greater than the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> value </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the inverse is an alias which the function attempts to enlarge to fit the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38e299df709c1fa18beea7d8b81e798f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e299df709c1fa18beea7d8b81e798f">&#9670;&nbsp;</a></span>trymodinv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool seal::BigUInt::trymodinv </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempts to calculate the inverse of a <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> with respect to the specified modulus, returning whether or not the inverse was successful and setting the inverse parameter to the inverse. The original <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is not modified. The inverse parameter is resized if and only if its bit count is smaller than the significant bit count of the modulus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">modulus</td><td>The modulus to calculate the inverse with respect to </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">inverse</td><td>Stores the inverse if the inverse operation was successful </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::Invalid_argument</td><td>if modulus is zero </td></tr>
    <tr><td class="paramname">std::Invalid_argument</td><td>if modulus is not greater than the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> value </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the inverse is an alias which the function attempts to enlarge to fit the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab774fd3eba01b2a38a6c9c286a5ec2bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab774fd3eba01b2a38a6c9c286a5ec2bd">&#9670;&nbsp;</a></span>uint64_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD std::size_t seal::BigUInt::uint64_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of std::uint64_t in the backing array used to store the <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> value.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> for a detailed description <a class="el" href="classseal_1_1BigUInt.html#abfc001758aba95b19e6fef361074ec7b">of</a> the format <a class="el" href="classseal_1_1BigUInt.html#abfc001758aba95b19e6fef361074ec7b">of</a> the backing array. </dd></dl>

</div>
</div>
<a id="a8fbc0f6b30a08016ea3c55ec23377c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fbc0f6b30a08016ea3c55ec23377c33">&#9670;&nbsp;</a></span>unalias()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::BigUInt::unalias </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resets an aliased <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> into an empty non-alias <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> with bit count of zero.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <a class="el" href="classseal_1_1BigUInt.html">BigUInt</a> is not an alias </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>seal/<a class="el" href="biguint_8h_source.html">biguint.h</a></li>
<li>seal/biguint.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
